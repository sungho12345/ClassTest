# 파이썬 공부

## 순서

- "hello world 출력"
- 기본문법
- 숫자계산
- 변수와 입력 사용
- 출력 방법
- bool과 비교, 논리 연산자
- 문자열 사용
- 리스트와 튜플 사용
- 시퀀스 자료형 활용
- 딕셔너리 사용
- if 조건문
- else 사용하여 분기
- elif 사용하여 여러방향으로 분기
- for 반복문
- while 반복문
- break, continue로 반복문 제어
- 계단식으로 별 출력
- FizzBuzz문제
- 터틀 그래픽스로 그림 그리기
- 리스트와 튜플 응용
- 2차원 리스트 사용
- 문자열 응용
- 딕셔너리 응용


### 0. 객체지향프로그래밍이란
프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법

- '추상화' 란 공통의 속성과 행위를 찾아서 타입을 정의하는 과정

### 1. "hello world 출력"

- 사용방법
```
print('hello world')
print("hello world")
```

### 2. 기본 문법

#### 2.1 세미콜론
- 파이썬은 기본적으로 세미콜론을 붙이지 않습니다. 그러나 세미콜론을 붙여도 문법에러는 발생하지 않습니다.
- 보통 한줄에 여러 구문을 사용할 때 세미콜론으로 구분할 수 있습니다.

#### 2.2 주석
- 주석에는 <strong>한줄주석</strong>과 <strong>블록주석</strong> 두가지가 있습니다.
- #뒤에있는 줄은 모두 주석이 됩니다.
- 블록주석은 각 줄마다 맨 앞에 #을 넣어줍니다.
-사용방법
```
# 한줄주석
# hello world 출력
print('hello world')
```
```
# 블록주석
# 더하기
# a = 1 + 2
# print('hello world')
```

#### 2.3 들여쓰기
- <strong>파이썬에서 들여쓰기는 중요합니다.</strong>
- 코드를 읽기 쉽도록 간격을 띄워서 작성하는 방법
- 파이썬은 들여쓰기 자체가 문법입니다.
- 들여쓰기는 공백(스페이스) 2칸, 4칸, 탭(tab) 등이 있습니다.
- 사용방법
```
if a == 10:
print('10입니다.') # 들여쓰기 문법 에러
```
```
if a == 10:
    print('10입니다.') # 올바른 문법(스페이스 4번 함)
```

#### 2.4 코드블록
- 특정한 동작을 위해서 코드가 모여있는 상태를 뜻합니다.
- 파이썬은 들여쓰기를 기준으로 코드블록을 구성합니다.
- 사용방법
```
if a == 10:
    print('10')
    print('입니다')
```
- 같은 블록은 들여쓰기 칸 수가 같아야 합니다.
- 공백과 탭 문자를 섞어쓰면 안 됩니다.

- 틀린 예
```
if a == 10:
  print('10')
    print('입니다')
```

### 3. 숫자 계산

#### 3.1 정수 계산하기

#### 사칙연산
- 정수나 실수에 따라 결과가 달라지지 않음

```
1 + 1
1 - 2
2 * 2
5 / 2
```

```
2
-1
4
2.5
```

```
5 // 2    # 나눗셈 후 소수점 이하를 버리는 연산자
5 % 2     # 나눗셈 후 나머지를 구하는 연산자
2 ** 10   # 거듭제곱을 구하는 연산자
```
```
2
1
1024
```

- 값을 정수로 만들기

```
>>> int(3.3)
3
>>> int(5 / 2)
2
>>> int('10')
10
```

- 객체의 자료형 알아내기


```
>>> type(10)
<class 'int'>
```

- 몫과 나머지를 함께 구하기

```
>>> divmod(5, 2)
(2, 1)           # tuple(튜플)형식으로 반환함
```

#### 3.2 실수 계산하기

```
>>> 3.5 + 2.1
5.6
>>> 4.3 - 2.7
1.5999999999999996
>>> 1.5 * 3.1
4.65
>>> 5.5 / 3.1
1.7741935483870968
```
실수 계산에서 오차문제는 나중에 보겠습니다.


- 실수와 정수 함께 계산

```
>>> 4.2 + 5
9.2        # 표현범위가 넓은 쪽으로 계산됌
```

- 값을 실수로 만들기

```
>>> float(5)
5.0
>>> float(1 + 2)
3.0
>>> float('5.3')
5.3
```

- 자료형 알아내기

```
>>> type(3.5)
<class 'float'>
```

참고
- 파이썬에서 복소수는 허수부 숫자 뒤에 j를 붙입니다.
두 실수를 복소수로 만들 때는 complex 를 사용하면 됩니다.
complex(1.2, 1.3)
(1.2+1.3j)

#### 3.3 괄호 사용
일반 수학과 같게 사용하면 됩니다.

### 4. 변수와 입력 사용
#### 4.1 변수 만들기
```
x = 10     
# 오른쪽에서 왼쪽으로 값이 할당됩니다.
# '='는 변수를 생성하면서 할당하는 것이지 같다는 뜻이 아닙니다.
# '같다' 는 '==' 입니다.

y = 'hello world'
# 문자열도 할당시킬수 있습니다.

>>> type(x)
<class 'int'>
# 객체의 자료형이 정수입니다.

>>> type(y)
<class 'str'>
# 객체의 자료형이 문자열 입니다.

>>> x, y, z = 10, 20, 30
>>> print(x, y, z)
10 20 30
# 여러개의 변수를 한번에 할당 할 수 있습니다.

>>> x = y = z = 10
>>> print(x, y, z)
10 10 10
# 한번에 모두 같은 수를 할당할 수 있습니다.
```
- 두 변수의 값 바꾸기

```
>>> x, y = 10, 20
>>> x, y = y, x
>>> print(x, y)
20 10
```
- 변수 삭제하기

```
>>> x = 10
>>> del x
# x의 값을 출력하려고 하면 변수가 삭제되었기 때문에 에러가 발생합니다.
```
- 빈 변수 만들기

```
>>> x = None
>>> print(x)
None
```

#### 4.2 변수로 계산

```
>>> a = 10
>>> b = 20
>>> c = a + b
>>> c
30

>>> a = 10
>>> a + 20
30
>>> a
10

>>> a = 10
>>> a = a + 20
# a에 값에 20을 더한 값을 다시 a 에 할당함
# a += 20 으로 줄여 쓸수도 있음
>>> a
30
```

- 부호 붙이기

```
>>> x = -10
>>> +x
-10
>>> -x
10
# 일반 수학과 같습니다.
```

#### 4.3 입력 값을 변수에 저장하기

- input 함수를 사용합시다.

```
>>> input()
hello world (엔터)
'hello world'
# 입력한 문자열이 그대로 출력됩니다.
# input 함수는 사용자가 입력한 값을 가져오는 함수입니다.
```

- input 함수의 결과를 변수에 할당

```
>>> x = input()
hello world (엔터)
>>> x
'hello world'

>>> x = input('문자열을 입력하세요: ')
문자열을 입력하세요: hello world (엔터)
>>> x
'hello world'

# 두 숫자의 합 구하기
a = input('a의 값 입력: ')
a의 값 입력: 10 (엔터)
b = input('b의 값 입력: ')
b의 값 입력: 20 (엔터)

print(a + b)
1020
# input에서 입력받은 값은 항상 문자열 형태이기 때문에 a와 b를 더했을때 30이 아니라 1020이 나왔습니다.

type(a)
<class 'str'>

a = int(input('a의 값 입력: ')
10 (엔터)
b = int(input('b의 값 입력: ')
20 (엔터)
# input으로 입력받은 값을 정수로 만들었습니다.

print(a + b)
30
```

- 입력 값을 변수 두 개에 저장

```
a, b = input('문자열 두개 입력: ').split()
# 입력받은 값을 공백을 기준으로 나눔
print(a)
print(b)
```

- map 사용하여 정수로 변환

```
a, b = map(int, input('숫자 두개 입력: ').split())

print(a + b)
```

- 입력받은 값을 콤마 기준으로 분리

```
a, b = map(int, input('숫자 두개 입력: ').split(','))

print(a + b)
# split괄호에 다른 단어를 넣으면 문자열을 나누는 기준을 바꿀수 있다.
# map을 사용해 float나 int로 바꿀수 있다.
```

### 5. 출력 방법
#### 5.1 값을 여러 개 출력

```
>>> print(1, 2, 3)
1 2 3

>>> print('hello', 'world')
hello world
```

- sep로 값 사이에 문자 넣기

```
>>> print(1, 2, 3, sep=', ') # sep에 콤마와 공백 지정
1, 2, 3

>>> print(4, 5, 6, sep=',') # sep에 콤마 지정
4,5,6

>>> print('hello', 'world', sep='') # sep에 빈 문자열 지정
helloworld

>>> print(1920, 1080, sep='x') # sep에 x 지정
1920x1080
```

- 줄바꿈 활용

```
>>> print(1, 2, 3, sep='\n')
1
2
3

>>> print('1\n2\n3')
1
2
3
```

- end 사용

```
print(1, end='') # end뒤에 빈 문자열 지정
print(2, end='')
print(3)

123

print(1, end=' ') # end뒤에 공백 문자열 지정
print(2, end=' ')
print(3)

1 2 3
```


### 6. 불과 비교 연산자
#### 6.1 불과 비교 연산자 사용

불(bool)은 참(True) 거짓(False)을 나타낸다.

```
>>> 3>1
True

>>> 1>3
False
```

- 비교연산자

```
>, <, ==, !=, is, is not 이 있다.

== 와 is, != 와 is not 은 비슷하지만 다르다.

1 == 1.0
True

1 is 1.0
False

# == 는 값 자체를 비교하지만 is 는 객체의 고유한 값(메모리 주소)을 비교하기 때문에 서로 작동 방식이 다르다.

값 비교에 is를 쓰지 않기

>>> a = -5
>>> a is -5
True
>>> a = -6
>>> a is -6
False

# 변수가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라 질수도 있기 때문
```

- 논리연산자

and, or, not 이 있다.

```
# and
True and True
True

True and False
False

False and True
False

False and False
False

# or
True or True
True

True or False
True

False or True
True

False or False
False

# not x
not True
False

not False 
True

# 논리연산자와 비교연산자를 같이 사용하면 비교연산자를 먼저 판단한다.
```

### 7. 문자열 사용
#### 7.1 여러줄로 된 문자열 사용

```
hello = 'hello world'

>>> hello
'hello world'

hello = '안녕하세요'

>>> hello
'안녕하세요'

# 작은따옴표뿐만 아니라 큰따옴표(" ") 
# 작은따옴표 3개(''' ''')
# 큰따옴표 3개(""" """)
# 로 묶을수도 있다.

# 여러줄로 된 문자열 사용에는 작은따옴표 3개나 큰따옴표 3개를 이용

>>> hello = '''hello world
안녕하세요.
python.'''

>>> print(hello)
hello world
안녕하세요.
python.
```

#### 7.2 문자열 안에 따옴표 포함

```
# 작은따옴표를 넣고싶다면 큰따옴표로 묶고 반대의 경우에는 작은따옴표로 묶으면 된다.

s = "python isn't difficult"

s = 'he said "python is easy"'

s = 'python isn\'t difficult' # 작은따옴표 앞에 역슬래시를 붙이면 된다.

# 같은 따옴표끼리는 넣고 묶을 수 없다.
```

### 8. 리스트와 튜플 사용
#### 8.1 리스트 만들기

변수에 값을 저장할 때 \[ ](대괄호)로 묶어주고 ,(콤마)로 구분

```
>>> a = [1, 2, 3, 4, 5]
>>> a
[1, 2, 3, 4, 5]

person = ['james', 17, 175.3, True] # 여러가지 자료형 저장 가능

# 빈리스트 만들기
a = []
b = list()

# range 사용
연속된 숫자를 생성한다.

range(횟수)
>>> range(10)
range(0,10)

a = list(range(10))
a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # 지정한 횟수 숫자는 생성되는 숫자에 포함되지 않는다.

range(시작, 끝)
range(5, 12)
[5, 6, 7, 8, 9, 10, 11]

range(시작, 끝, 증가폭)
range(0, 10, 2)
[0, 2, 4, 6, 8]

# 증가폭이 음수면 감소함

# 리스트 요소의 합 sum()을 사용함.
```

#### 8.2 튜플 사용
튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제 할 수 없음(읽기 전용)

```
>>> a = (1, 2, 3, 4, 5)
>>> a
(1, 2, 3, 4, 5)

>>> a = 1, 2, 3, 4, 5 # 괄호를 사용하지 않아도 튜플을 만들 수 있다.
>>> a
(1, 2, 3, 4, 5)

>>> p = ('james', 17, 175.3, True)
>>> p
('james', 17, 175.3, True)

# 요소가 한개인 튜플
>>>(38) # 이건 튜플이 아니라 그냥 값임
38
>>>(38, ) # 값 한개를 넣고 콤마를 넣어줘야함
(38, )
>>> 38, # 괄호가 없어도 됨
(38, )
```

- range를 사용하여 튜플 만들기

```
>>> a = tuple(range(10))
>>> a
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

>>> b = tuple(range(5, 12))
>>> b
(5, 6, 7, 8, 9, 10, 11)

>>> c = tuple(range(-4, 10, 2))
>>> c
(-4, -2, 0, 2, 4, 6, 8)

# 튜플을 리스트로 만들고 리스트를 튜플로 만들기

>>> a = [1, 2, 3]
>>> tuple(a)
(1, 2, 3)

>>> b = (1, 2, 3)
>>> list(b)
[1, 2, 3]

# 리스트와 튜플로 변수 만들기

>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3

>>> a, b, c = (1, 2, 3)
>>> print(a, b, c)
1 2 3

# 리스트, 튜플 언패킹

>>> x = [1, 2, 3]  # 리스트 패킹
>>> a, b, c = x
>>> print(a, b, c)
1 2 3

>>> y = (1, 2, 3)  # 튜플 패킹
>>> d, e, f = y
>>> print(d, e, f)
1 2 3

# 입력값을 변수 두개에 저장하기

>>> x = input().split()
>>> a, b = x  # a, b = input().split() 과 같음
>>> print(a, b) 
```

### 9. 시퀀스 자료형

값이 연속적(sequence)으로 이어져 있는 자료형들을 배웠다.

#### 9.1 시퀀스 자료형

```
# 특정 값이 있는지 확인
>>> a = [1, 2, 3, 4, 5, 6, 7, 8]
>>> 3 in a  # in 은 있는지 확인함
True
>>> 9 in a
False
>>> 9 not in a
True        # 앞에 not을 붙이면 없는지 확인함
# 튜플, range, str도 같은 방법으로 확인 가능

>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b   # 객체와 객체를 연결해 새 객체를 만듦
[1, 2, 3, 4, 5, 6]

단, range는 연결할 수 없는데, list나 tuple을 이용하면 연결 가능

>>> list(range(0, 5)) + list(range(5, 10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# '+' 연산자로 문자열을 연결 가능
>>> 'hello ' + 'world'
hello world

# 문자열과 숫자 연결
>>> 'hello, ' + str(10) # 문자열로 변환
hello, 10
>>> 'hello, ' + str(10.5) # 실수도 문자열로 변환
hello, 10.5

# 시퀀스 객체 반복
>>> [0, 1, 2] * 3
[0, 1, 2, 0, 1, 2, 0, 1, 2]

이것또한 range는 list와 tuple로 반복 가능하다.
```

#### 9.2 시퀀스 객체의 요소 개수 구하기

```
>>> a = [0, 1, 2, 3]# list
>>> len(a)          # length에서 따옴
4

>>> len(range(0,10,2))
5                   # 숫자가 생성되는 개수 구함

# 문자열 길이
>>> hello = '안녕하세요'
>>> len(hello)
5

>>> hello = '안녕 하세요'
>>> len(hello)
6
# 공백까지도 개수로 친다.
```

#### 9.3 인덱스 사용

시퀀스 객체에의 각 요소는 순서가 정해져 있으며, 이 순서를 인덱스라고 부름.

```
>>> a = [1, 2, 3, 4, 5]
>>> a[0]
1
>>> a[3]
4
# 0부터 시작함

# tuple, range, list, str도 대괄호에 인덱스를 지정하면 요소를 가져올 수 있다.

>>> r = range(0, 10, 2)
>>> r[2]
4

>>> hello = 'hello world'
>>> hello[3]
l
>>> hello    # 객체에 인덱스를 지정하지 않음면 전체를 출력함
'hello world'

# 음수 인덱스 지정
음수로 지정하면 뒤에서부터 요소에 접근한다.
>>> a = [1, 2, 3, 4]
>>> a[-1]
4
>>> a[-4]
1

# 인덱스의 범위를 벗어나면 에러가 발생한다.
>>> a = [1, 2, 3]
>>> a[4]
error

# 마지막 요소 접근
>>> a = [1, 2, 3]
>>> len(a)
3
>>> a[3]
error   # 인덱스는 0부터라 3을 넣으면 에러가 발생 
>>> a[2]
3

# 요소에 값 할당
>>> a = [0, 0, 0, 0] # 0이 4개 들어있는 리스트
>>> a[0] = 1
>>> a[1] = 2
>>> a[2] = 3
>>> a[3] = 4
>>> a
[1, 2, 3, 4]
>>> a[3]
4

# 단, tuple과 range, str은 해당되지 않는다.
# 읽기 전용이기 때문임.

# del로 요소 삭제
>>> a = [1, 2, 3, 4]
>>> del a[2]
>>> a
[1, 2, 4]
>>> len(a)
3
# 마찬가지로 tuple, range, str은 안됌.
```

#### 9.4 슬라이스 사용
슬라이스는 시퀀스 객체의 일부를 잘라내는 것임.

시퀀스객체[시작인덱스 : 끝인덱스]

```
>>> a = [0, 1, 2, 3, 4]
>>> a[0 : 2] # 0부터 2까지 잘라서 새 리스트 만듦
[0, 1]
>>> a[2, 4]
[2, 3]
>>> a[2, 5]  # 끝인덱스는 실제로 가져오려는 인덱스보다 1을 더 크게 지정해야 한다.
[2, 3, 4]
>>> a[1,-1]  # 음수 인덱스 지정
[1, 2, 3]

# 인덱스 증가폭 사용
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a[1:8:2] # 엔덱스 1부터 2씩 증가시키면서 인덱스 7까지 가져옴
[1, 3, 5, 7]

# 인덱스 생략
>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a[:7] # 처음부터 인덱스 6까지
[0, 1, 2, 3, 4, 5, 6]
>>> a[6:] # 인덱스 6부터 끝까지
[6, 7, 8, 9]
>>> a[:]  # 리스트 전체를 가져옴
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a[:7:2] # 처음부터 2씩 증가시키면서 인덱스 6까지 가져옴
[0, 2, 4, 6]
>>> a[5:1:-1] #인덱스 5부터 1씩 감소시키면서 인덱스 2까지 가져옴
[5, 4, 3, 2]
```
- len응용

```
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[0:len(a)]
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

- tuple, range, str에 슬라이스 사용

```
>>> b = (0, 10, 20, 30, 40, 50, 60, 70, 80, 90)
>>> b[4:7]
(40, 50, 60)

>>> r = range(10)
>>> r
range(0, 10)
>>> r[4:7]
range(4, 7)  # 지정된 범위의 숫자를 생성하는 range객체를 새로 만듦.

>>> hello = 'hello world'
>>> hello[4:7]
'o w'
```

- slice 객체 사용

```
>>> range(10)[slice(4, 7, 2)]
range(4, 7, 2)

# slice객체를 하나만 만든 뒤 여러 시퀀스 객체에 사용
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> s = slice(4, 7)
>>> a[s]
[40, 50, 60]
>>> r = range(10)
>>> r[s]
range(4, 7)
>>> hello = 'hello world'
>>> hello[s]
'o w'
```

- 슬라이스에 요소 할당

```
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a', 'b', 'c']
>>> a
[0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a'] # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어듦
# 반대로 늘어나기도 함
>>> a
[0, 10, 'a', 50, 60, 70, 80, 90]

# tuple, range, str은 읽기 전용이기 때문에 슬라이스 범위를 지정하더라도 요소를 할당할 수 없다.
```

- del로 슬라이스 삭제

```
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> del a[2:5]
>>> a
[0, 10, 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> del a[::2]
>>> a
[10, 30, 50, 70, 90]

# 또한 tuple, range, str은 del로 삭제할수 없다.
```

### 10. 딕셔너리 사용
#### 10.1 딕셔너리 만들기

파이썬에서는 연관된 값을 묶어서 저장하는 용도로 딕셔너리라는 자료형을 제공한다.

```
# 딕셔너리는 {}(중괄호) 안에 키:값 형식으로 저장하면 콤마로 구분한다.

>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}

# 키 이름이 중복되면 가장 뒤에 있는 값만 사용하고 중복되는 키는 저장되지 않음.
>>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux
{'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}

# 딕셔너리의 키에는 문자열, 정수, 실수, 불도 섞어서 사용 가능하다.
# 하지만 리스트와 딕셔너리를 사용할 수 없다.
# 값에는 문자열, 정수, 실수, 불, 리스트, 딕셔너리 사용 가능

- 빈 딕셔너리 만들기
>>> x = {}
>>> x
{}
>>> y = dict()
>>> y
{}

- dict로 딕셔너리 만들기
# 키=값 형식으로 만든다
>>> lux1 = dict(health = 490, mana = 334, melee = 550, armor = 18.72)
>>> lux1
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}

# (키, 값) 형식의 튜플을 나열
>>> lux2 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])
>>> lux2
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}

# dict안에서 중괄호로 딕셔너리를 생성
>>> lux3 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})
>>> lux3
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}

# 차례대로 zip에 넣은뒤 다시 dict에 넣어줌
>>> lux4 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))
>>> lux4
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

#### 10.2 딕셔너리의 키에 접근하고 값 할당

```
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health']
490
>>> lux['mana']
334
>>> lux # 키를 지정하지 않으면 전체를 출력함
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}

>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health'] = 2000 # health의 값을 2000으로 변경
>>> lux['health']
2000

>>> lux['mana_regen'] = 3.28  # 키를 추가하고 값 할당
>>> lux
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}

- 딕셔너리에 키가 있는지 확인
>>> 'health' in lux
True
>>> 'health_regen' in lux
False
>>> 'health_regen' not in lux
True

- 딕셔너리의 키 개수 구하기
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> len(lux)
4

# 딕셔너리는 중괄호를 사용하고 키와 값을 1:1 관계로 지정함
```

### 11. if 조건문

```
if 조건식:
    코드

- if 조건문에서 코드 생략하기

>>> if x == 10:
        pass  # 조건문의 형태를 유지하고 나중에 할일을 주석으로 남겨놓는 방식
```

- 들여쓰기

들여쓰기 칸 수를 맞추는 것이 중요하다.

```
if x == 10:
    print('x는')
    print('10입니다.')
# x 가 10이면 두개다 실행된다.

if x == 10:
    print('x는')
print('10입니다.')
# x가 10이 아니면 '10입니다'만 실행된다.
```

- 중첩 if 조건문

```
x = 15

if x >= 10:
    print('10 이상입니다.')

    if x == 15:
        print('15입니다.')

    if x == 20:
        print('20입니다.')

# 여기서도 들여쓰기가 중요
```

- 사용자가 입력한 값에 if 조건문 사용

```
x = int(input())

if x == 10:
    print('10입니다.')

if x == 20:
    print('20입니다.')
```

### 12. else사용하여 두 방향으로 분기

```
# if 조건문에 해당이 되지 않을 때 else로 가서 실행한다.
x = 5
if x == 10:
    print('10입니다.')
else:
    print('10이 아닙니다.')

# 들여쓰기 중요.
```

- if 조건문의 동작 방식

```
if True:
    print('참')    # True는 참
else:
    print('거짓')
 
if False:
    print('참')
else:
    print('거짓')    # False는 거짓
 
if None:
    print('참')
else:
    print('거짓')    # None은 거짓

# 숫자는 0이면 거짓, 아니면 참
# 문자열은 내용이있을때 참, 아니면 거짓
```

- 조건식 여러개 지정

```
x = 10
y = 20
 
if x == 10 and y == 20:     # x가 10이면서 y가 20일 때
    print('참')
else:
    print('거짓')
```

- 중첩 if 조건문과 논리 연산자

```
if x > 0:
    if x < 20:
        print('20보다 작은 양수.')

if x > 0 and x < 20:
    print('20보다 작은 양수.')

if 0 < x < 20:
    print('20보다 작은 양수.')
```

### 13. elif 사용

조건식을 여러개 지정하여 각 조건마다 다른 코드를 실행할 수 있다.

```
x = 10

if x == 5:
    print('5입니다.')
elif x == 15:
    print('15입니다.')
else:
    print('x는 5도 15도 아닙니다.')
```

### 14. for 반복문

```
# hello world 100번 출력하기

for i in range(100):
    print('hello world')

for i in range(100):
    print('hello world', i)
# hello world 뒤에 0부터 99까지 붙는다.

for i in range(5, 12):
    print('hello world', i)
# hello world 뒤에 5부터 11까지 나옴.

for i in range(0, 10, 2):
    print('hello world', i)
# hello world 뒤에 0, 2, 4, 6, 8 이 각각 붙어서 나옴.

for i in range(10, 0):  # 동작하지 않음
    print('hello world')

for i in range(10, 0, -1):
    print('hello world', i)
# 10부터 1까지 -1씩 감소

for i in reverse(range(10)): # reverse를 사용하여 숫자의 순서를 반대로
    print('hello world', i)
# 9부터 0까지 10번 반복

- 입력한 횟수대로 반복
count = int(input())

for i in range(count):
    print(i,end = ' ')

# 반복문의 변수 i를 변경할 수 있을까?

for i in range(10):
    print(i, end = ' ')
    i = 10
# 안됌.
```

- 시퀀스 객체로 반복하기

```
a = [10, 20, 30, 40, 50]
for i in a:
    print(i)

fruits = ('apple', 'grape', 'orange')
for fruit in fruits:
    print(fruit)

for letter in 'python':
    print(letter, end = ' ')

for letter in reverse('python')
    print(letter, end = ' ')
# reverse는 원본 객체를 바꾸지 않으면 뒤집어서 꺼내기만 함.
```

### 15. while 반복문

```
초기식
while 조건식:
    반복할 코드
    변화식

i = 0
while i < 100:            # i 가 100 미만일때만 반복
    print('hello world')
    i += 1                # 한번 반복에 끝에서 i를 계속 1씩 더해줌

- 입력한 횟수대로 반복

count = int(input())

i = 0
while i < count:
    print('hello world', i)
    i += 1

# 반대

count = int(input())

while count > 0:
    print('hello world', count)
    count -= 1
```

- 반복횟수가 정해지지 않은 경우

파이썬에서 난수를 생성하려면 random 모듈이 필요함

```
import random

random.random() # random모듈의 random함수 호출

random.randint(1, 6) # randint함수로 1부터 6까지 난수 생성
```

-  1과 6사이의 난수를 생성한 뒤 3이 나오면 반복을 끝낸다.

```
import random

i = 0
while i != 3:
    i = random.randint(1, 6)
    print(i)
```

- random.choice

```
dice = [1, 2, 3, 4, 5, 6]
random.choice(dice) # dice리스트에서 무작위로 숫자 선택

# random.choice함수는 시퀀스 객체를 받으므로 list, tuple, range, str 전부 넣어도 된다.
```

- while 반복문으로 무한루프

```
while True:
    print('hello world')

# 조건식이 항상 참이면 무한루프가 만들어진다.
# True 대신 True로 취급하는 값을 상요해도 무한루프로 동작
# ex) 0이 아닌 숫자, 내용이 있는 문자열
```

### 16. break, continue로 반복문 제어

```
i = 0
while True:
    print(i)
    i += 1
    if i == 100:
        break
# i가 100이 되면 while문을 벗어난다.

for i in range(10000):
    print(i)
    if i == 100:
        break
```

- continue로 코드 실행 건너뛰기

```
for i in range(100):
    if i % 2 == 0:  # i가 2의 배수(짝수)라면
        continue    # 아래 코드를 실행하지 않고 건너뛴다.
    print(i)

i = 0
while i < 100:
    i += 1
    if i % 2 == 0:  # i가 2의 배수(짝수)라면
        continue    # 아래 코드를 실행하지 않고 건너뛴다.
    print(i)
```

- 입력한 횟수대로 반복하기

```
count = int(input())

i = 0
while True:
    print(i)
    i += 1
    if i == count:
        break
```

- 입력한 숫자까지 홀수만 출력하기

```
# while 문
count = int(input())

i = 0
while i < count:
    i += 1
    if i % 2 != 0:
        print(i)
    else:
        continue

# for문
count = int(input())

for i in range(count+1):
    if i % 2 != 0:
        print(i)
    else:
        continue
```

### 16. 계단식으로 별 출력

중첩루프를 사용하자.

```
# 5x5 별모양 출력
for i in range(5):
    for j in range(5):
        print('*',end='')
    print('')

# 계단식으로 별 출력
for i in range(5):
    for j in range(i+1):
        print('*',end='') # end=''를 추가해 줄바꿈을 방지함
    print('') # 가로방향으로 별을 다 그린뒤 다음줄로 넘어감
```

### 17. FizzBuzz

- 1에서 100까지 출력
- 3의 배수는 Fizz 출력
- 5의 배수는 Buzz 출력
- 3과 5의 공배수는 FizzBuzz 출력

```
for i in range(1, 101):  # 1부터 100까지 반복
    if i % 15 == 0:      # 3과 5의 최소공배수인 15의 배수면 FizzBuzz 출력
        print('FizzBuzz')
    elif i % 3 == 0:     # 3의 배수면 Fizz 출력
        print('Fizz')
    elif i % 5 == 0:     # 5의 배수면 Buzz 출력
        print('Buzz')
    else:                # 모두 해당되지 않으면 그냥 숫자 출력
        print(i)
# 15의 배수를 먼저 조건으로한 이유는 3이나 5의 배수를 먼저 처리해 버리면 15의 배수의 경우는 오지 않아서임.
```

- 코드 단축하기

```
for i in range(1, 101):
    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)

>>> 'Fizz' * True
'Fizz'
>>> 'Fizz' * False
'' 
>>> 'Fizz' + 'Buzz'
'FizzBuzz'

# or 연산자를 사용하는데, 빈문자열은 False로 취급하고, i는 항상 1이상의 숫자이므로 or로 연산하면 i만 남게되어 숫자가 그대로 출력됌.
```

### 17. 터틀 그래픽스

코랩에서 터틀그래픽스를 사용하기 위해서는 다음과 같음

```
!pip3 install ColabTurtle
import ColabTurtle.Turtle as t
t.initializeTurtle()
```

```
t.forward()  # 앞으로 이동 괄호안에는 거리를 입력
t.backward() # 뒤로 이동 
t.right()    # 오른쪽으로 회전 괄호안에는 각도를 입력
t.left()     # 왼쪽으로 회전

# 순서대로 짧게 줄임
t.fd
t.bd
t.rt
t.lt
```

- 사각형 그리기

```
!pip3 install ColabTurtle
import ColabTurtle.Turtle as t
t.initializeTurtle()

for i in range(4): # 4번반복
    t.fd(100)      # 앞으로 100이동
    t.rt(90)       # 오른쪽으로 90도 회전
```

### 18. 리스트와 튜플 응용

리스트의 기능
- 요소를 추가/삭제
- 정보를 조회

- 리스트에 요소 추가

```
# append 요소 하나를 추가
# extend 리스트를 연결하여 확장
# insert 특정 인덱스에 요소 추가

>>> a = [10, 20, 30]
>>> a.append(500)
>>> a
[10, 20, 30, 500]
>>> len(a)
4

# 빈 리스트에도 추가 가능
>>> a = []
>>> a.append(10)
>>> a
[10]

# 리스트안에 리스트 추가
>>> a = [10, 20, 30]
>>> a.append([500, 600])
>>> a
[10, 20, 30, [500, 600]]
>>> len(a)
4  # [500, 600]이라는 요소 하나를 끝에 추가해서 5개가 아니라 4개임.


- 리스트 확장

>>> a = [10, 20, 30]
>>> a.extend([500, 600])
>>> a
[10, 20, 30, 500, 600]
>>> len(a)
5

- 리스트의 특정 인덱스에 요소 추가

>>> a = [10, 20, 30]
>>> a.insert(2,500)
>>> a
[10, 20, 500, 30]
>>> len(a)
4

#리스트 끝에 500 추가
>>> a. insert(len(a),500)
>>> a
[10, 20, 30, 500]

- 리스트에서 요소 삭제

# pop 마지막 요소 또는 특정 인덱스의 요소를 삭제
# remove 특정 값을 찾아서 삭제

>>> a = [10, 20, 30]
>>> a.pop()
30
>>> a
[10, 20]  # del을 사용해도 됌.

>>> a = [10, 20, 30]
>>> a.remove(20)
>>> a
[10, 30]

>>> a = [10, 20, 30, 20]
>>> a.remove(20)
>>> a
[10, 30, 20]  # 처음 찾은 값을 삭제함.

- 리스트에서 특정 값의 인덱스 구하기
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.index(20)  # 가장 먼저 찾은 20의 인덱스를 구함
1

- 특정 값의 개수 구하기
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.count(20)
2

- 리스트의 순서를 뒤집기
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.reverse()
>>> a
[40, 20, 15, 30, 20, 10]

- 리스트의 요소를 정렬
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.sort()
>>> a
[10, 15, 20, 20, 30, 40]

# sort와 sorted
# sort는 메소드를 사용한 리스트를 변경
# sorted는 정렬된 새 리스트를 생성

- 리스트의 모든 요소 삭제
>>> a = [10, 20, 30]
>>> a.clear()
>>> a
[]

>>> a = [10, 20, 30]
>>> del a[:]
>>> a
[]

- 리스트를 슬라이스로 조작
>>> a = [10, 20, 30]
>>> a[len(a):] = [500]
>>> a
[10, 20, 30, 500]

>>> a = [10, 20, 30]
>>> a[len(a):] = [500, 600]
>>> a
[10, 20, 30, 500, 600]
```

- 리스트의 할당과 복사

```
>>> a = [0, 0, 0, 0, 0]
>>> b = a
# 리스트를 다른 변수에 할당하면 리스트는 두개가 될것 같지만 실제로는 하나다.
>>> a is b
True
>>> b[2] = 99
>>> a
[0, 0, 99, 0, 0]
>>> b
[0, 0, 99, 0, 0]

# 리스트를 두개로 하기 위해서
>>> a = [0, 0, 0, 0, 0]
>>> b = a.copy()
>>> a is b
False
>>> a == b
True
```

- for 반복문으로 요소 출력

```
>>> a = [1, 2, 3, 4, 5]
>>> for i in a:
        print(i)
>>> for i in [1, 2, 3, 4, 5]:
        print(i)        

a = [1, 2, 3, 4, 5]
for i in range(len(a)):
    print(a[i])
```

- 인덱스와 요소를 함께 출력

```
>>> a = [1, 2, 3, 4, 5]
>>> for index, value in enumerate(a):
        print(index, value)

# 인덱스를 1부터 출력하고 싶다면
>>> for index, value in enumerate(a, start = 1):
        print(index, value)
# enumerate(a,1) 로 써도 됌.
```



- while 반복문으로 요소 출력

```
a = [1, 2, 3, 4, 5]
i = 0
while i < len(a):
    print(a[i])
    i +=1
```

- 가장 작은수와 가장 큰 수 구하기

```
a = [3, 1, 2, 5, 4]
smallest = a[0]
for i in a:
    if i < smallest:
        smallest = i


largest = a[0]
for i in a:
    if largest < i:
        largest = i
# 작은수의 반대로 하면 큰수가 나온다.

- sort 사용
a = [3, 1, 2, 5, 4]
a.sort()
a[0]  # 오름차순이라 첫번째 인덱스가 가장작은수

a.sort(reverse = True)  # 내림차순

- max, min 사용
a = [3, 1, 2, 5, 4]
min(a)
max(a)
# 간단하다.
```

- 요소의 합계 구하기

```
a = [1, 2, 3, 4, 5]
x = 0
for i in a:
    x += i:

- sum 사용
a = [1, 2, 3, 4, 5]
sum(a)
# 간단함.
```

- 리스트 표현식 사용

파이썬은 리스트 안에 for반복문과 if조건문사용이 가능함

```
>>> a = [i for i in range(10)]
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> b = list(i for i in range(10))
>>> b
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> c = [i + 5 for i in range(10)]
# 0부터 9까지 숫자를 생성하면서 값에 5를 더하여 리스트 생성
>>> c 
[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

>>> d = [i * 2 for i in range(10)]
>>> d
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

- 리스트 표현식에서 if 조건문 사용

```
>>> a = [i for i in range(10) if i % 2 == 0]
# 0~9의 숫자 중 2의 배수인 숫자(조건식에 참인)로 리스트 생성
>>> a
[0, 2, 4, 6, 8]
```

- for반복문과 if조건문 여러번 사용

```
a = [i * j for j in range(2, 10) for i in range(1, 10)]
# 구구단 2단부터 9단까지
```

- 리스트에 map 사용

```
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> for i in range(len(a)):
        a[i] = int(a[i])
# 인덱스 요소에 하나하나 접근한 뒤 int로 변환하여 다시 저장

- map 사용
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> a = list(map(int, a))

- map에는 반복가능한 객체도 넣을 수 있음
>>> a = list(map(str, range(5)))
>>> a
['0', '1', '2', '3', '4']

- input().split()과 map
>>> a = input().split()
10 20
>>> a
['10', '20']

>>> a = map(int, input().split())
10 20
>>> a
error
>>> list(a)
[10, 20]

- 맵 객체는 변수 여러개에 저장할 수 있음(언패킹)
>>> a, b = [10, 20]
>>> a
10
>>> b
20
```

- 튜플 응용

```
- 특정 값의 인덱스 구하기
>>> a = (38, 21, 53, 62, 19, 53)
>>> a.index(53)
2

- 특정 값의 개수 구하기
>>> a = (10, 20, 30, 15, 20, 40)
>>> a.count(20)
2

- for반복문으로 요소 출력
>>> a = (38, 21, 53, 62, 19)
>>> for i in a:
        print(i, end='')
38 21 53 62 19

- 튜플 표현식 사용
>>> a = tuple(i for i in range(10) if i % 2 == 0)
>>> a
(0, 2, 4, 6, 8)

- 튜플에서 map사용
>>> a = (1.2, 2.5, 3.7, 4.6)
>>> a = tuple(map(int, a))
>>> a
(1, 2, 3, 4)

- 튜플에서 가장작은수 가장큰수 합계 구하기
>>> a = (38, 21, 53, 62, 19)
>>> min(a)
19
>>> max(a)
62
>>> sum(a)
193
```

### 19. 2차원 리스트 사용
#### 19.1 2차원 리스트 만들고 요소에 접근

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a
[[10, 20], [30, 40], [50, 60]]

a = [[10, 20],
     [30, 40],
     [50, 60]]  # 이러면 알아보기 쉽다.
>>> a[0][0]
10
>>> a[0][1] = 1000  # 값 할당, 20 > 1000
```

- 톱니형 리스트

가로크기가 불규칙한 리스트를 뜻함.

```
a = [[10, 20],
     [500, 600, 700],
     [9],
     [30, 40],
     [8],
     [800, 900, 1000]]

# append를 사용하여 동적으로 생성가능
```

- 2차원 튜플

```
a = ((10, 20), (30, 40), (50, 60))  # 튜플 안에 튜플을 넣은 2차원 튜플
b = ([10, 20], [30, 40], [50, 60])  # 튜플 안에 리스트를 넣음
c = [(10, 20), (30, 40), (50, 60)]  # 리스트 안에 튜플을 넣음


a[0][0] = 500      # 안쪽 튜플은 변경할 수 없음. TypeError 발생

a[0] = (500, 600)  # 바깥쪽 튜플은 변경할 수 없음. 
TypeError 발생

b[0][0] = 500      # 안쪽 리스트는 변경할 수 있음

b[0] = (500, 600)  # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생

c[0][0] = 500      # 안쪽 튜플은 변경할 수 없음. TypeError 발생

c[0] = (500, 600)  # 바깥쪽 리스트는 변경할 수 있음

# 튜플은 읽기전용이라 변경 불가
```

#### 19.2 for반복문으로 리스트의 요소 전부 출력

- for반복문 한번만 사용

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> for x,y in a:
        print(x,y)
# 2차원 리스트에서 가로크기가 일정해야한다.
# 가로크기가 크지 않을 때 유용.
```

- for반복문 두번 사용

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> for i in a:
        for j in i:
            print(j, end='')
        print()
```

- for와 range 사용

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> for i in range(len(a)):     # 세로 크기
        for j in range(len(i)): # 가로 크기
            print(a[i][j], end='')
        print()
```

- while반복문 한번 사용

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> i = 0
>>> while i < len(a):
        x, y = a[i]
        print(x, y)
        i += 1
```

- while반복문 두번 사용

```
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> i = 0
>>> while i < len(a):
        j = 0
        while j < len(a[i]):
            print(a[i][j], end='')
            j += 1
        print()
        i += 1
```

#### 19.3 반복문으로 리스트 만들기

- for반복문으로 1차원 리스트 만들기

```
>>> a = []  # 빈 리스트 생성

>>> for i in range(10):
    a.append(0)  # append로 요소 추가

>>> print(a)
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

- for반복문으로 2차원 리스트 만들기

```
>>> a = []
>>> for i range(3):
        line = []    # 안쪽 리스트로 사용할 빈 리스트 생성
        for j in range(2):
            line.append(0)
        a.append(line)
>>> print(a)
[[0, 0], [0, 0], [0, 0]]
```

- 리스트 표현식으로 2차원 리스트 만들기

```
>>> a = [[0 for j in range(2)] for i in range(3)]
>>> a 
[[0, 0], [0, 0], [0, 0]]

>>> a = [[0] * 2 for i in range(3)]
>>> a
[[0, 0], [0, 0], [0, 0]]
# [0]에 2를 곱하면 [0, 0]이 된다.
```

- 톱니형 리스트 만들기

```
a = [3, 1, 3, 2, 5]  # 가로 크기를 저장한 리스트
b = []  # 빈 리스트 생성
for i in a:  # 가로크기를 꺼내면서 5번 반복
    line = []  # 안쪽 리스트로 사용할 빈 리스트 생성
    for j in range(i):  # 리스트 a에 저장된 가로 크기만큼 반복
        line.append(0)
    b.append(line)
print(b)

# 결과 
# [[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]

- 리스트 표현식 이용
>>> a = [[0] * i for i in [3, 1, 3, 2, 5]]
>>> a
[[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]
```

#### 19.4 2차원 리스트의 할당과 복사

1차원 리스트와 비슷하다

```
>>> a = [[10, 20], [30, 40]]
>>> b = a
>>> b[0][0] = 500
>>> a
[[500, 20], [30, 40]]
>>> b
[[500, 20], [30, 40]]
# 두개로 보이지만 사실 하나의 리스트다.
```

- copy로 복사

```
>>> a = [[10, 20], [30, 40]]
>>> b = a.copy()
>>> b[0][0] = 500
>>> a
[[500, 20], [30, 40]]
>>> b
[[500, 20], [30, 40]]
# 1차원 리스트에서는 바뀌지 않았는데 2차원 리스트에서는 아니다.
# 완전히 복사하기 위해서는 copy 모듈의 deepcopy를 사용
```

- deepcopy

```
>>> a = [[10, 20], [30, 40]]
>>> import copy  # copy 모듈
>>> b = copy.deepcopy(a)
>>> b[0][0] = 500  # 이제 다른값을 할당해보자.
>>> a
[[10, 20], [30, 40]]  # 안바뀜.
>>> b
[[500, 20], [30, 40]]  # 당연히 바뀜.
```

### 20. 문자열 응용
#### 20.1 문자열 조작

- 문자열 바꾸기(replace)

```
>>> 'hello world'.replace('world', 'python')
'hello python'

>>> s = 'hello world'
>>> s = s.replace('world', 'python')
>>> s
'hello python'
```

- 문자 바꾸기(translate)

문자열 안의 문자를 다른 문자로 바꿈

```
>>> table = str.maketrans('aeiou','12345')  
# str.maketrans로 변환 테이블을 만듦.('바꿀문자', '새문자')
>>> 'apple'.translate(table)
'1ppl2'
```

- 문자열 분리하기(split)

```
>>> 'apple, pear, grape, pineapple, orange'.split(', ')
# 괄호 안에 입력에 의해서 콤마와 공백을 기준으로 문자열을 분리
['apple', 'pear', 'grape', 'pineapple', 'orange']
```

- 구분자 문자열과 문자열 리스트 연결(join)

```
>>> ' '.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])
# join앞의 작은 따옴표 안의 문자에 따라 연결하는 방법이 달라짐
'apple pear grape pineapple orange'
```

- 소문자를 대문자로, 대문자를 소문자로 바꾸기(upper, lower)

```
>>> 'python'.upper()
'PYTHON'
>>> 'PYTHON'.lower()
'python'
```

- (왼쪽, 오른쪽, 양쪽)공백 삭제(lstrip, rstrip, strip)

```
>>> '   Python   '.lstrip()
'Python   '

>>> '   Python   '.rstrip()
'   Python'

>>> '   Python   '.strip()
'Python'
```

- (왼쪽, 오른쪽, 양쪽)의 특정 문자 삭제(lstrip, rstrip, strip)

함수 소괄호 안에 넣는 문자로 삭제할 문자를 정한다

```
>>> ', python.'.lstrip(',.')
' python.' # 왼쪽만 삭제된 모습.

>>> ', python.'.rstrip(',.')
', python' # 오른쪽만 삭제된 모습.

>>> ', python.'.strip(',.')
' python'  # 양쪽 다 삭제된 모습
```

- 문자열을 (왼쪽, 오른쪽, 가운데) 정렬(ljust, rjust, center)

지정된 길이로 만든 뒤 남은 공간을 공백으로 채운다.
시작하는 곳이 왼쪽이냐 오른쪽이냐 가운데냐에 따라 나뉨

```
>>> 'python'.ljust(10)
'python    '

>>> 'python'.rjust(10)
'    python'

>>> 'python'.center(10)
'  python  '

>>> 'python'.center(11) # 홀수면 왼쪽에 공백이 한칸이 더 들어간다.
'   python  '
```

- 메서드 체이닝

메서드를 줄줄이 연결한다고 해서 메서드 체이닝이다.

```
>>> 'python'.rjust(10).upper()
'    PYTHON'
```

- 문자열 왼쪽에 0 채우기(zfill)

zero fill이라고 해서 zfill이다.

```
# 지정된 길이가 문자열의 길이보다 작다면 아무것도 채우지 않는다.
>>> '35'.zfill(5)
'00035'
>>> '3.5'.zfill(6)
'0003.5'
>>> 'hello'.zfill(10)
'00000hello'
```

- 문자열 위치 찾기(fine, rfine, index, rindex)

```
# 왼쪽부터 가장 먼저 찾은 문자열의 인덱스를 반환함.
>>> 'apple pineapple'.find('pl')
2
>>> 'apple pineapple'.find('xy')
-1
# 찾는 문자열이 없으면 -1을 반환함.

- 오른쪽부터 문자열 위치 찾기
>>> 'apple pineapple'.rfind('pl')
12

# index는 찾는 문자열이 없으면 에러가 발생함, 나머지는 똑같음
>>> 'apple pineapple'.index('pl')
2

- 오른쪽부터 문자열 위치 찾기
>>> 'apple pineapple'.rindex('pl')
12
```

- 문자열 개수 세기(count)

```
>>> 'apple pineapple'.count('pl')
2
```
#### 20.2 문자열 서식 지정자와 포매팅 사용

- 서식 지정자로 문자열 넣기

```
>>> 'I am %s.' % 'james'
'I am james'

>>> name = 'maria'
>>> 'I am %s.' % name
'I am maria'
```

- 서식 지정자로 숫자 넣기

```
>>> 'I am %d years old' % 20
'I am 20 years old'

- 서식 지정자로 소수점 표현
>>> '%f' % 2.3
'2.300000'  # %f는 기본적으로 소수점 이하 6자리까지 표시함

>>> '%.2f' % 2.3
2.30  # 자릿수 지정
```

- 서식 지정자로 문자열 정렬

```
>>> '%10s' % 'python'
'    python'  # 문자열을 지정된 길이로 만든 뒤 오른쪽 정렬을 하고 남는 공간을 공백으로 채움

- 왼쪽정렬
>>> '%-10s' % 'python'
'python    '
```

- 서식 지정자로 문자열 안에 값 여러개 넣기

```
>>> 'Today is %d %s.' % (3, 'April')
'Today is 3 April'
```

- format 메서드 사용

```
>>> 'hello {0}'.format('world')
'hello world'
>>> 'hello {0}'.format(100)
'hello 100'

- format 메서드로 여러개의 값 넣기
>>> 'hello {0] {2} {1}'.format('world', 'April', 3)
'hello world 3 April'

- 같은 값 여러개 넣기
>>> 'hello {0} {0} {1} {1}'.format('world', '300')
'hello world world 300 300'

- 인덱스 생략하기 
>>> 'hello {} {} {}'.format('world', 'hi', 'hello')
'hello world hi hello'
# 인덱스를 생략하면 순서대로 들어감

- 인덱스대신 이름 지정
>>> 'hello {language} {april}'.format(language = 'python', april = 3)
'hello python 3'
```

- 문자열 포매팅에 변수를 그대로 사용하기

```
language = 'python'
april = 3
f'hello {language} {april}'
'hello python 3'

# 중괄호 출력은 {{,}}처럼 두번 사용하면 된다.
```

- format 메서드로 문자열 정렬

'{인덱스:<길이}'.format(값)

```
>>> '{0:<10}'.format('python')
'python    '
# 부등호 방향이 왼쪽을 가리키면 왼쪽정렬 
# 남는 공간을 공백으로 채움

>>> '{0:>10}'.format('python')
'    python'

>>> '{:>10}'.format('python')
'    python'
# 인덱스를 사용하지 않다면 0을 빼고 써도 된다.
```

- 숫자 개수 맞추기

정수와 실수 앞에 0을 넣어서 개수를 맞추는 방법임

```
- 정수
>>> '%03' % 1
'001'
>>> '{0:03d}'.format(35)
'035'

- 실수
>>> '%08.2f' % 3.6  # %0개수.자리수f
'00003.60'
>>> '{0:%08.2f}'.format(3.6)
'00003.60'
# 실수는 개수에 정수, 소수점, 소수점 이하 자릿수가 모두 포함됨
```

- 채우기와 정렬을 조합해서 사용

'{인덱스:[채우기][정렬]>[길이].[자리수][자료형]}'

```
- 정수
>>> '{0:0>10}'.format(15)
'0000000015'

- 실수
>>> '{0:0>10.2f}'.format(15)
'0000015.00'

# 채우기 부분에 0외에 다른 것을 넣어도 됌
# 채우기 부분을 생략하면 공백이 들어감
```

### 21. 딕셔너리 활용하기

```
setdefault(키)는 딕셔너리에 키-값 쌍을 추가함
>>> x = {'a': 10, 'b': 20}
>>> x.setdefault('c')
>>> x
{'a': 10, 'b': 20, 'c': None}

>>> x.setdefault('d', 100)
>>> x
{'a': 10, 'b': 20, 'c': None, 'd': 100}

update(키=값)는 딕셔너리에서 키의 값을 수정한다.

>>> x = {'a': 10, 'b': 20}
>>> x.update(a=90)
>>> x
{'a': 90, 'b': 20}
>>> x.update(c=30)  # 없는 키도 추가 가능하다
>>> x
{'a': 90, 'b': 20, 'c': 30}

키가 숫자일 경우에는 딕셔너리를 넣어서 값을 수정할 수 있다.
>>> y = {1: 'one, 2: 'two'}
>>> y.update({1: 'ONE', 3: 'THREE'})
>>> y
{1: 'ONE', 2: 'two', 3: 'THREE'}

# 리스트와 튜플 이용
>>> y.update([[2, 'TWO'], [4, 'FOUR']])
>>> y
{1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}

>>> y.update(zip([1, 2], ['one', 'two']))
>>> y
{1: 'one', 2: 'two', 3: 'THREE', 4: 'FOUR'}

# 딕셔너리에서 키-값 쌍 삭제하기
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.pop('a')
10
>>> x
{'b': 20, 'c': 30, 'd': 40}

>>> x.pop('z', 0)  # 키가 없을 때는 기본값으로 지정한 0을 반환한다.
0

>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> del x['a']
>>> x
{'b': 20, 'c': 30, 'd': 40}

>>> x.popitem()  # 마지막 키-값 쌍을 삭제한다.

>>> x.clear()  # 모든 키-값 쌍을 삭제

>>> x.get('a')  # 키의 값을 가져옴
10
>>> x.items()  # 딕셔너리의 키-값 쌍을 모두 가져옴

>>> x.keys()  # 키를 모두 가져옴

>>> x.values()  # 값을 모두 가져옴

리스트와 튜플로 딕셔너리 만들기
>>> keys = ['a', 'b', 'c', 'd']
>>> x = dict.fromkeys(keys)
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}

>>> y = dict.fromkeys(keys, 100)
>>> y
{'a': 100, 'b': 100, 'c': 100, 'd': 100}

반복문을 사용해 딕셔너리의 키-값 쌍을 모두 출력하기
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> for key,value in x.items():
        print(key, value)

>>> for key in x.items():  # 키만 출력
        print(key, end = '')

>>> for value in x.items():  # 값만 출력
        print(value, end = '')

# 딕셔너리 표현식 사용하기
>>> keys = ['a', 'b', 'c', 'd']
>>> x = {key: value for key, value in dict.fromkeys(keys).items()}
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}

>>> {key: 0 for key in dict.fromkeys(['a', 'b', 'c', 'd']).keys()}  # 키만 가져옴
{'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> {value: 0 for value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.values()}  # 값을 키로 사용
{10: 0, 20: 0, 30: 0, 40: 0}

# value와 key의 자리를 바꾸면 키와 값의 자리를 바꿀 수 있다.

# 딕셔너리는 for 반복문으로 반복하면서 키-값 쌍을 삭제하면 안된다.

# if문으로 키-값 쌍 삭제하기
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x = {key: value for key, value in x.items() if value != 20}  # 값이 20이 아닌것만 키-값에 넣겠다는 if문임
>>> x
{'a': 10, 'c': 30, 'd': 40}

# 딕셔너리 안에서 딕셔너리 사용하기
terrestrial_planet = {
    'Mercury': {
        'mean_radius': 2439.7,
        'mass': 3.3022E+23,
        'orbital_period': 87.969
    },
    'Venus': {
        'mean_radius': 6051.8,
        'mass': 4.8676E+24,
        'orbital_period': 224.70069,
    },
    'Earth': {
        'mean_radius': 6371.0,
        'mass': 5.97219E+24,
        'orbital_period': 365.25641,
    },
    'Mars': {
        'mean_radius': 3389.5,
        'mass': 6.4185E+23,
        'orbital_period': 686.9600,
    }
}
 
print(terrestrial_planet['Venus']['mean_radius'])  
# 딕셔너리가 두단계로 사용되고 있으므로 대괄호를 두번 사용한다.
6051.8

# 파이썬의 할당과 복사

>>> x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> y = x
>>> y is x
True  # 이름은 다르지만 같은 딕셔너리임

>>> x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}
>>> y = x.copy()
>>> x is y
False
>>> x == y
True
>>> y['a']['python'] = '2.7.15'
>>> x
{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}
>>> y
{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}
# 중첩 딕셔너리는 둘다 반영된다.

# deepcopy 메서드를 사용하면 중첩 딕셔너리까지 복사가 된다.
>>> x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}
>>> import copy
>>> y = copy.deepcopy(x)
>>> y['a']['python] = '2.7.15'
>>> x
{'a': {'python': '2.7'}, 'b': {'python': '3.6'}}
>>> y
{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}}

```

### 22. 세트 사용하기
```
>>> fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
>>> fruits
{'grape', 'strawberry', 'orange', 'pineapple', 'cherry'}  # 순서가 정해져 있지 않기 때문에 항상 다르게 나온다.

>>> 'grape' in fruits
True
>>> 'peach' in fruits
False

# set를 사용하여 세트 만들기
>>> a = set('apple')
>>> a
{'e','p','l','a'}  # 중복된 문자는 포함되지 않는다.

>>> b = set(range(5))
>>> b
{0, 1, 2, 3, 4}

>>> c = set()
>>> c
set()

>>> type(c)
<class 'set'>  # type을 사용하여 자료형의 종류를 알 수 있다.

# 리스트, 딕셔너리와 다르게 세트 안에 세트를 넣을 수 없다.

# 집합 연산
a | b  # or연산자
a & b  # and연산자
a - b  # 차집합
a ^ b  # 대칭차집합(= XOR연산자)
a |= b # 할당 연산자
a &= b # 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장
a -= b # 현재 세트에서 다른 세트를 뺌
a ^= b # 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 현재 세트에 저장

# 상위집합인지 확인
a <= b # 현재 세트가 다른 세트의 부분집합인지 확인
a >= b # 다른 세트가 현재 세트의 부분집합인지 확인
a < b  # 현재 세트가 다른 세트의 진부분집합인지 확인
a > b  # 다른 세트가 현재 세트의 진부분집합인지 확인

# 세트가 같은지 다른지 확인
a == b

# 세트가 겹치지 않는지 확인
a.isdisjoint({1, 2, 3, 4})  # 겹치는 요소가 없으면 True

# 세트에 요소 추가
>>> a = {1, 2, 3, 4}
>>> a.add(5)
>>> a
{1, 2, 3, 4, 5}

# 세트에 특정 요소 삭제
>>> a.remove(3)
>>> a
{1, 2, 4, 5}  # remove는 삭제하려는 요소가 없으면 에러 발생
>>> a.discard(2)
>>> a
{1, 4, 5}  # discard는 삭제하려는 요소가 없으면 그냥 넘어감

# 임의의 요소 삭제
>>> a = {1, 2, 3, 4}
>>> a.pop()
1
>>> a
{2, 3, 4}  # 임의의 요소를 삭제하고 해당요소를 반환한다. 요소가 없으면 에러 발생

# 모든 요소 삭제
>>> a.clear()
>>> a
set()

# 요소 개수 구하기
>>> a = {1, 2, 3, 4}
>>> len(a)
4

# 세트 할당과 복사
>>> a = {1, 2, 3, 4}
>>> b = a
>>> a is b
True
>>> a.add(5)
>>> b
{1, 2, 3, 4, 5}  # a와 b는 세트가 하나임

# copy사용해야 두개로 만들 수 있다.
>>> b = a.copy()
>>> b.add(6)
>>> a
{1, 2, 3, 4, 5}
>>> b
{1, 2, 3, 4, 5, 6}

# 반복문으로 세트의 요소 모두 출력
>>> for i in {1, 2, 3, 4, 5}:
        print(i)
1
2
3
4
5
>>> a = {1, 2, 3, 4, 5}
>>> for i in a:
        print(i)
1
2
3
4
5

# 세트 표현식 사용하기
>>> a = {i for i in 'apple'}
>>> a
{'l', 'a', 'p', 'e'}

>>> a = {i for i in 'apple' if not in 'apl'}
>>> a
{'e'}
```
### 22. 파일 사용하기
```
# 파일에 문자열 쓰기, 읽기

# 쓰기
file = open('hello.txt', 'w')  # w가 쓰기모드
file.write('hello world!')
file.close

# 읽기
file = open('hello.txt', 'r')  # r이 읽기모드
s = file.read()
print(s)
file.close()

# 자동으로 파일 객체 닫기
with open('hello.txt', 'r') as file:  # 읽기 전용 모드로 열기
    s = file.read()
    print(s)

# 반복문으로 문자열 여러 줄을 파일에 쓰기
with open('hello.txt', 'w') as file:
    for i in range(3):
        file.write('hello,world {0}\n'.format(i))
hello,world 0
hello,world 1
hello,world 2

# 리스트에 들어있는 문자열을 파일에 쓰기
lines = ['안녕하세요.\n', '파이썬\n', '코딩도장입니다.\n']
with open('hello.txt', 'w') as file:
    file.writelines(lines)
안녕하세요.
파이썬
코딩도장입니다.

# 파일의 내용을 한 줄씩 리스트로 가져오기
with open('hello.txt', 'r') as file:
    lines = file.readlines()
    print(lines)
['안녕하세요.\n', '파이썬\n', '코딩도장입니다.\n']

# 파일의 내용을 한 줄씩 읽기
with open('hello.txt', 'r') as file:
    line = None  # None으로 초기화하는 이유는 다음 while반복문에서 바로 거짓이 되어버려 반복문이 끝나기 때문임.
    while line != '':
        line = file.readline()
        print(line.strip('\n'))  # \n기호를 없애는 이유는 프린트 자체가 개행이 있기 때문임.

# for반복문으로 파일의 내용을 줄 단위로 읽기
with open('hello.txt', 'r') as file:
    for line in file:
        print(line.strip('\n'))

# 파이썬 객체를 파일에 저장하기
import pickle
name = 'james'
age = 17
address = '용인시'
scores = {'korean': 90, 'english': 95, 'mathematics': 85, 'science': 82}

with open('james.p', 'wb') as file:
    pickle.dump(name, file)
    pickle.dump(age, file)
    pickle.dump(address, file)
    pickle.dump(scores, file)

# 파일에서 파이썬 객체 읽기
with open('james.p','rb') as file:
    name = pickle.load(file)
    age = pickle.load(file)
    address = pickle.load(file)
    scores = pickle.load(file)
    print(name)
    print(age)
    print(address)
    print(scores)
```

### 23. 회문판별
```
# 방법_1
# 반복문으로 문자 검사
word = input()
is_palindrome = True  # 회문 판별값을 저장할 변수 초깃값은 True
for i in range(len(word)//2):  # 0부터 문자열 길이의 절반만큼 반복
    if word[i] != word[-1-i]:  # 왼쪽문자와 오른쪽 문자를 비교해서 문자가 다르면
        is_palindrome = False  # 회문이 아님
        break
print(is_palindrome)

# 방법_2
# 시퀀스 뒤집기로 문자 검사
wod = input()
print(word == word[::-1])

# 방법_3
# 리스트와 reversed사용
word = 'level'
list(word) == list(reversed(word))

# 방법_4
# 문자열의 join매서드와 reversed사용
word = 'level'
word == ''.join(reversed(word))


```

### 24. 함수 사용하기

```
>>> def 함수이름():
        코드
# 함수를 만들고 출력할 때는 호출한다고 함

# 덧셈 함수 만들기, 함수에서 값을 받으려면 괄호 안에 변수 이름을 지정해주면 됨
>>> def add(a,b):
        print(a+b)
>>> add(10, 20)
30

# 함수의 결과를 반환하기, return을 사용하면 값을 함수 바깥으로 반환할 수 있고, 함수에서 나온 값을 변수에 저장할 수 있음
>>> def add(a, b):
        return a + b
>>> x = add(10, 20)
>>> x
30

>>> print(add(10, 20))
30

# 함수에서 값을 여러 개 반환하기
>>> def add_sub(a, b):
        return a + b, a - b
>>> x, y = add_sub(10, 20)
>>> x
30
>>> y
-10

>>> def three():
        return 1, 2, 3

        return (1, 2, 3)

        return [1, 2, 3]
        # 위 3개 전부 맞음(리스트냐 튜플 직적 반환)

>>> x = add_sub(10, 20)
>>> x
(30, -10)
# 변수를 하나만 지정하면 하나에 두개가 저장됨

# 함수의 호출 과정, 함수는 스택(stack)방식으로 호출됨
```

### 25. 함수에서 위치 인수와 키워드 인수 사용하기

```
# 위치인수와 리스트 언패킹 사용하기
# 위치인수 : 함수에 인수를 순서대로 넣는 방식

>>> def print_number(a, b, c):
        print(a)
        print(b)
        print(c)

# 언패킹 사용하기, 리스트 또는 튜플 앞에 *(에스터리스크)를 붙여서 함수에 넣어주면 됨

x = [10, 20, 30]
print_numbers(*x) == print_numbers(10, 20, 30)

# 리스트 변수 대신 리스트 앞에 바로 *를 붙여도 동작은 같음
# 매개변수 개수와 리스트의 요소 개수는 같아야 함

# 가변인수 함수 만들기
# 넣은 숫자 개수만큼 출력됨
>>> def print_numbers(*args):
        for arg in args:
            print(arg)

# 키워드 인수 사용하기
>>> def personal_info(name, age, address):
        print('이름: ', name)
        print('나이: ', age)
        print('주소: ', address)
>>> personal_info('홍길동', 30, '서울시 용산구 이촌동')
이름: 홍길동
나이: 30
주소: 서울시 용산구 이촌동

# 키워드 인수 사용
>>> personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')

# 키워드 인수와 딕셔너리 언패킹 사용
딕셔너리 앞에 **(애스터리스크 두개)를 붙여서 함수에 넣어줌
>>> def personal_info(name, age, address):
        print('이름: ', name)
        print('나이: ', age)
        print('주소: ', address)
>>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**x)
이름: 홍길동
나이: 30
주소: 서울시 용산구 이촌동
# 딕셔너리 변수 대신 딕셔너리 앞에 바로 **를 붙여도 동작은 같음
# 매개변수 이름, 개수가 같아야 함
# 애스터리스크를 두개 쓰는 이유: 딕셔너리는 키-값 쌍으로 되어있기 때문에 한번만 쓰면 키값이 나온다. 그래서 두번 쓰면 값으로 나오게 되는 것임

# 키워드 인수를 사용하는 가변 인수 함수 만들기
>>> def personal_info(**kwargs):
        for kw, arg in kwargs.items():
            print(kw, ': ', arg, sep='')

# 매개변수에 초깃값 지정하기
>>> def personal_info(name, age, address='비공개'):
        print('이름: ',name)
        print('나이: ',age)
        print('주소: ',address)
>>> personal_info('홍길동', 30)
이름: 홍길동
나이: 30
주소: 비공개

# 초깃값이 지정된 매개변수는 뒤쪽에 몰아줘야 한다
def personal_info(name, age, address='비공개'):     
def personal_info(name, age=0, address='비공개'):
def personal_info(name='비공개', age=0, address='비공개'):
```

### 26. 함수에서 재귀호출 사용하기

```
def hello():
    print('hello, world')
    hello()
hello()
# 언제 끝날지를 정하지 않으면 끝까지 된다(파이썬은 1000번)

def hello(count):
    if count == 0:
        return
    # count가 0이면 끝냄

    print('hello,world',count)
    count -= 1  # count를 1씩 감소시킴
    hello(count)  # 다시 hello에 넣는다
hello(6)  # hello 함수 호출

# 재귀호출로 팩토리얼 구하기
def factorial(n):
    if n == 1:
        return 1  # n이 1이면 1을 반환하고 재귀호출 끝냄
    return n * factorial(n-1)  # n과 factorial함수에 n-1을 넣어서 반환된 값을 곱함
print(factorial(5))
```

### 27. 람다 표현식 사용하기

```
def plus_ten(x):
    return x+10
plus_ten(1)

# plus_ten함수를 람다 표현식을 이용해 작성
# 람다 표현식은 이름이 없는 함수를 만들어서 함수를 호출할 수 없다
# 람다 표현식을 변수에 할당해주면 됨
lambda x: x + 10

plus_ten = lambda x: x + 10
plus_ten(1)

(lambda x: x + 10)(1)  # 이것도 가능함
# 람다 표현식 안에서는 변수를 만들 수 없음
# 변수가 필요한 코드일 경우에는 def로 함수를 작성하는 것이 좋음
# 람다 표현식 바깥에 있는 변수는 사용할 수 있음

y = 10
(lambda x: x + y)(1)
# 람다표현식은 함수의 인수부분에서 간단하게 함수를 만들기 위해서 사용함

def plus_ten(x):
    return x + 10
list(map(plus_ten, [1, 2, 3]))

list(map(lambda x: x + 10, [1, 2, 3]))

# 람다 표현식과 map, filter, reduce 함수 사용
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
list(map(lambda x : str(x) if x % 3 == 0 else x, a))
# 람다표현식 안에서 if, else를 사용할 때는 :(콜론)을 붙이지 않음
# 식1 if 조건식 else 식2 형식임
# 람다표현식에서는 if를 사용했으면 else를 반드시 사용해야함, elif를 사용할 수 없음

# map에 객체를 여러 개 넣기
a = [1, 2, 3, 4, 5]
b = [2, 4, 6, 8, 10]
list(map(lambda x, y: x*y,a,b))

# filter 사용 / filter(함수, 반복가능한객체)
def f(x):
    return x > 5 and x < 10

a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
list(filter(f, a))  # filter는 x>5 and x<10인 결과가 참인 요소만 가져오고 거짓인 요소는 버림

# 함수 f를 람다 표현식으로 만들어서 filter에 넣어보자
a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
list(filter(lambda x: x>5 and x<10,a))

# reduce 사용
# 반복가능한 객체의 각요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환하는 함수
# from functools import reduce
# reduce(함수, 반복가능한 객체)
def f(x,y):
    return x + y
a = [1, 2, 3, 4, 5]
from functools import reduce
reduce(f,a)

# f를 람다 표현식으로 만들어서 reduce에 넣어보자
a = [1, 2, 3, 4, 5]
from functools import reduce
reduce(lambda x, y: x+y,a)
```

### 28. 클로저 사용하기

```
x = 10
def foo():
    print(x)

foo()
print(x)
# 함수를 포함하여 스크립트 전체에서 접근할 수 있는 변수를 전역변수라고 함

def foo():
    y = 10
    print(y)

foo()
print(y)
# foo함수 안에 지역변수로 정의했기 때문에 foo의 지역변수는 출력할 수 없다.

# 함수 안에서 전역 변수 변경하기
x = 10
def foo():
    x = 20
    print(x)
foo()
print(x)      # 지역 변수에서 변경해도 전역 변수는 바뀌지 않음

# 함수 안에서 전역 변수의 값을 변경하려면 global키워드를 사용해야 함
x = 10
def foo():
    global x    # x를 전역 변수로 만듬
    x = 20      # x는 번역변수
    print(x)    # 전역 변수 출력

foo()
print(x)

# 함수 안에서 함수 만들기
def print_hello():
    hello = "hello, world!"
    def print_message():
        print(hello)    # 바깥쪽 함수의 지역 변수를 사용
    print_message()
print_hello()

def A():
    x = 10
    def B():
        x = 20
    B()
    print(x)
A()
# 작은범위의 B함수에서 x를 정의해도 바깥 A함수에서 정의한 x값은 바뀌지 않음
# 파이썬에서는 함수에서 변수를 만들면 항상 현재 함수의 지역 변수가 됨

def A():
    x = 10
    def B():
        nonlocal x    # 현재 함수의 바깥쪽에 있는 지역 변수 사용
        x = 20        # A의 지역변수 x에 20 할당
    B()
    print(x)
A()

def A():
    x = 10
    y = 100
    def B():
        x = 20
        def C():
            nonlocal x
            nonlocal y
            x = x + 30
            y = y + 300
            print(x)
            print(y)
        C()
    B()
A()
# nonlocal은 현재 함수의 바깥쪽에 있는 지역 변수를 찾을 때 가장 가까운 함수부터 먼저 찾음

# global 키워드는 함수가 몇 단계든 상관없이 무조건 전역 변수를 사용하게 됨
x = 1
def A():
    x = 10
    def B():
        x = 20
        def C():
            global x
            x = x + 30
            print(x)
        C()
    B()
A()

# 클로저 사용하기
def calc():
    a = 3
    b = 5
    def mul_add(x):
        return a * x + b  # 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 계산
    return mul_add        # mul_add함수를 반환(함수 이름만 반환해야함 괄호 X)
c = calc()
print(c(1), c(2), c(3), c(4), c(5))

#lambda로 클로저 만들기(람다표현식과 많이 사용됨)
def calc():
    a = 3
    b = 5
    return lambda x: a * x + b
c = calc()
print(c(1), c(2), c(3), c(4), c(5))

# 클로저의 지역 변수 변경하기
def calc():
    a = 3
    b = 5
    total = 0
    def mul_add(x):
        nonlocal total
        total = total + a * x + b
        print(total)
    return mul_add
c = calc()
c(1)
c(2)
c(3)
```

### 29. 클래스 사용하기

```
# 클래스와 메서드 만들기
# 클래스 class에 클래스 이름을 지정하고 콜론을 붙인다
# 메서드는 클래스 안에 있는 함수를 뜻함
# 메서드의 첫 번째 매개변수는 반드시 self를 지정해야함
class person:
    def greeting(self):
        print('hello')

james = person()        # james가 person의 인스턴스임
james.greeting()        # 인스턴스 메서드, 메서드는 클래스가 아니라 인스턴스를 통해 호출함

# 인스턴스 b에서 메서드 append를 호출해서 값을 추가함
b = list(range(10))
b.append(20)
b

# 속성 사용하기
# 속성은 __init__ 메서드에서 만든다
class person:
    def __init__(self):
        self.hello = '안녕하세요'

    def greeting(self):
        print(self.hello)
james = person()
james.greeting()

class person:
    def __init__(self, name, age, address):
        self.hello = '안녕하세요'
        self.name = name
        self.age = age
        self.address = address
    
    def greeting(self):
        print('{0} 저는 {1}입니다.'.format(self.hello, self.name))

maria = person('마리아', 20, '서울사 서초구 반포동')
maria.greeting()
print('이름:', maria.name)
print('나이:', maria.age)
print('주소:', maria.address)

# 비공개 속성 사용하기
# 비공개 속성은 __속성과 같이 이름이 밑줄 두개로 시작해야함
class person:
    def __init__(self, name, age, address, wallet):
        self.hello = '안녕하세요'
        self.name = name
        self.age = age
        self.address = address
        self.__wallet = wallet       # 변수 앞에 __를 붙여서 비공개 속성으로 만듦


    def pay(self, amount):
        if amount > self.__wallet:   # 사용하려고 하는 금액보다 지갑에 든 돈이 적을 때
            print('돈이 모자라요..')
            return
        self.__wallet -= amount      # 비공개 속성은 클래스 안의 메서드에서만 접근할 수 있음
        print('이제 {0}원 남았어요.'.format(self.__wallet))
        
    
maria = person('마리아', 20, '서울시 서초구 반포동', 10000)
# maria.__wallet -= 10000           # 클래스 바깥에서 비공개 속성에 접근하면 에러가 발생함
maria.pay(10000)
```

### 30. 클래스 속성과 정적, 클래스 메서드 사용하기

```
# 클래스 속성 사용하기
# def 클래스이름:
#     속성 = 값
class person:
    bag = []

    def put_bag(self, stuff):
        self.bag.append(stuff)

james = person()
james.put_bag('책')

maria = person()
maria.put_bag('열쇠')

print(james.bag)
print(maria.bag)
# 클래스 속성은 클래스에 속해있으며 모든 인스턴트에서 공유함
# self는 현재 인스턴트를 뜻하므로 클래스 속성을 지칭하기에는 조금 모호함
# self.bag.append(stuff) > person.bag.append(stuff)

class person:
    def __init__(self):       # 가방을 여러 사람이 공유하지 않으려면 bag을 인스턴트 속성으로 만들면 됨
        self.bag = []

    def put_bag(self, stuff):
        self.bag.append(stuff)

james = person()
james.put_bag('책')

maria = person()
maria.put_bag('열쇠')

print(james.bag)
print(maria.bag)

# 인스턴스 속성은 인스턴스별로 독립되어 있으며 서로 영향을 주지 않음

# 비공개 클래스 속성 사용하기
# def 클래스이름:
#     __속성 = 값
# 클래스 안에서만 접근할 수 있고, 클래스 바깥에서는 접근할 수 없음
class knight:
    __item_limit = 10                 # 비공개 클래스 속성

    def print_item_limit(self):
        print(knight.__item_limit)    # 클래스 안에서만 접근할 수 있음

x = knight()
x.print_item_limit()

# print(knight.__item_limit)          # 클래스 바깥에서는 접근할 수 없음

# 정적 메서드 사용하기
## class 클래스이름:
##     @staticmethod
##     def 메서드(매개변수1, 매개변수2):
##         코드
# 정적메서드는 메서드의 실행이 외부 상태에 영향을 끼치지 않는 순수 함수를 만들 때 사용함
class calc:
    @staticmethod     # 정적 메서드
    def add(a, b):
        print(a + b)

    @staticmethod     # 정적 메서드
    def mul(a, b):
        print(a * b)

calc.add(10, 20)      # 클래스에서 바로 메서드 호출
calc.mul(10, 20)      # 클래스에서 바로 메서드 호출

# 클래스 메서드 사용하기
## class 클래스이름:
##    @classmethod
##    def 메서드(cls, 매개변수1, 매개변수2):  # 클래스 메서드는 첫번째 매개변수에 cls를 지정해야함
##        코드
# 사람 클래스 person을 만들고 인스턴스가 몇 개 만들어졌는지 출력하는 메서드
class person:
    count = 0

    def __init__(self):
        person.count += 1     # 인스턴스가 만들어질 때
                              # 클래스 속성 count에 1을 더함
    @classmethod
    def print_count(cls):
        print('{0}명 생성되었습니다.'.format(cls.count))    # cls로 클래스 속성에 접근

james = person()
maria = person()

person.print_count()

# 날짜 클래스 만들기
class Date:
    @staticmethod
    def is_date_valid(date_string):
        year, month, day = map(int, date_string.split('-'))
        return month <= 12 and day <= 31

if Date.is_date_valid('2000-10-31'):
    print('올바른 날짜 형식입니다.')
else:
    print('잘못된 날짜 형식입니다.')

# 시간 클래스 만들기
class Time:
    def __init__(self, hour, minute, second):
        self.hour = hour
        self.minute = minute
        self.second = second
    
    @staticmethod
    def is_time_valid(time_string):
        hour, minute, second = map(int, time_string.split(':'))
        return hour <= 24 and minute <= 59 and second <= 60

    @staticmethod
    def from_string(time_string):
        hour, minute, second = map(int, time_string.split(':'))
        return Time(hour, minute, second)
"""
    @classmethod
    def from_string(cls, time_string):
        hour, minute, second = map(int, time_string.split(':'))
        time = cls(hour, minute, second)
        return time


    @staticmethod
    def from_string(time_string):
        hour, minute, second = map(int, time_string.split(':'))
        if Time.is_time_valid(time_string):
            return Time(hour, minute, second)
        else:
            return None
"""


time_string = input()
 
if Time.is_time_valid(time_string):
    t = Time.from_string(time_string)
    print(t.hour, t.minute, t.second)
else:
    print('잘못된 시간 형식입니다.')
```

### 31. 클래스 상속 사용하기
```
# 클래스 상속 사용하기
# 기반클래스, 파생클래스가 있음

# 사람클래스로 학생클래스 만들기
# class 기반클래스이름:
#     코드
# class 파생클래스이름(기반클래스이름):
#     코드
class Person:
    def greeting(self):
        print('안녕하세요')

class Student(Person):
    def study(self):
        print('공부하기')

james = Student()
james.greeting()
james.study()
# Student클래스에는 greeting 메서드가 없지만 Person 클래스를 상속받았으므로 greeting 메서드를 호출할 수 있음

# 상속 관계와 포함 관계 알아보기
# 상속은 명확하게 같은 종류이며 동등한 관계일 때 사용함
class Person:
    def greeting(self):
        print('안녕하세요')

class Student(Person):
    def study(self):
        print('공부하기')

# 학생 클래스가 아니라 사람 목록을 관리하는 클래스를 만든다면 다음과 같이 리스트 속성에 Person인스턴스를 넣어서 관리하면 됨
class Person:
    def greeting(self):
        print('안녕하세요')

class Personlist():
    def __init__(self):
        self.person_list = []         # 리스트 속성에 Person 인스턴스를 넣어서 관리
    
    def append_person(self, person):  # 리스트 속성에 Person 인스턴스를 추가하는 함수
      self.person_list.append(person) 
#  동등한 관계가 아닐 때는 속성에 인스턴스를 넣는 포함 방식을 사용하면 됨

# 기반 클래스의 속성 사용
# super()를 사용해서 기반 클래스의 __init__ 메서드를 호출해줌
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요'

class Student(Person):
    def __init__(self):
        print('Student __init__')
        super().__init__()
        self.school = '파이썬 코딩도장'

james = Student()
print(james.school)
print(james.hello)

# 만약 파생 클래스에서 __init__ 메서드를 생략한다면 기반 클래스의 __init__이 자도으로 호출되므로 super() 사용하지 않아도 됨
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요'

class Student(Person):
    pass

james = Student()
print(james.hello)

# 메서드 오버라이딩 사용
class Person:
    def greeting(self):
        print('안녕하세요')

class Student(Person):
    def greeting(self):
        super().greeting()    # 기반 클래스의 메서드 호출하여 중복을 줄임
        print('안녕하세요 안녕하세요')

james = Student()
james.greeting()
# 메서드 오버라이딩은 원래 기능을 유지하면서 새로운 기능을 덧붙일 때 사용함

# 다중 상속 사용하기
# class 기반클래스이름1:
#     코드
# class 기반클래스이름2:
#     코드
# class 파생클래스이름(기반클래스이름1, 기반클래스이름2):
#     코드
# 사람 클래스와 대학교 클래스를 만든 뒤 다중 상속으로 대학생 클래스 만들기
class Person:
    def greeting(self):
        print('안녕하세요')
class University:
    def manage_credit(self):
        print('학점관리')
class Undergraduate(Person, University):
    def study(self):
        print('공부하기')

james = Undergraduate()
james.greeting()        # 안녕하세요.: 기반 클래스 Person의 메서드 호출
james.manage_credit()   # 학점 관리: 기반 클래스 University의 메서드 호출
james.study()           # 공부하기: 파생 클래스 Undergraduate에 추가한 study 메서드

# 다이아몬드 상속
class A:
    def greeting(self):
        print('안녕하세요 A입니다')

class B(A):
    def greeting(self):
        print('안녕하세요 B입니다')

class C(A):
    def greeting(self):
        print('안녕하세요 C입니다')

class D(B, C):    # 왼쪽부터 출력됨
    pass

x = D()
x.greeting()

D.mro()   # 메서드 탐색 순서가 나옴

# 추상클래스 사용하기
# 추상클래스는 메서드의 목록만 가진 클래스이며 상속받는 클래스에서 메서드 구현을 강제하기 위해 사용
from abc import *

class 추상클래스이름(metaclass=ABCMeta):
    @abstractmethod
    def 메서드이름(self):
        코드

from abc import *

class StudentBase(metaclass=ABCMeta):
    @abstractmethod
    def study(self):
        pass

    @abstractmethod
    def go_to_school(self):
        pass

class Student(StudentBase):
    def study(self):
        print('공부하기')

    def go_to_school(self):
        print('학교가기')

james = Student()
james.study()
james.go_to_school()
# 추상 클래스를 이용할 때는 abstractmethod가 붙은 모든 추상메서드를 구현 해야지 오류가 안걸림
# 추상클래스로 인스턴스를 만들면 에러가 발생함, 오로지 상속에만 사용, 파생클래스에서 반드시 구현해야 할 메서드를 정해 줄 때 사용
```

### 32. 두 점 사이의 거리 구하기
```
# 두 점사이의 거리 구하기
import math

class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

p1 = Point2D(x = 30, y = 20)
p2 = Point2D(x = 60, y = 50)

print('p1: {} {}'.format(p1.x, p1.y))   # 점1
print('p2: {} {}'.format(p2.x, p2.y))   # 점2
# 피타고라스 정리 c^2 = a^2 + b^2
a = p2.x - p1.x     # 선 a의 길이
b = p2.y - p1.y     # 선 b의 길이
c = math.sqrt((a*a) + (b*b))
# c = math.sqrt(math.pow(a, 2) + math.pow(b, 2))  math.pow(값, 지수)
# c = math.sqrt((a ** 2) + (b ** 2))
print(c)

# 사각형의 넓이 구하기
class Rectangle:
    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
 
rect = Rectangle(x1=20, y1=20, x2=40, y2=30)
 
a = rect.x2 - rect.x1
b = rect.y2 - rect.y1
area = a * b

print(area)

# 두 점 사이의 거리 구하기
import math
 
class Point2D:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
 
length = 0.0
p = [Point2D(), Point2D(), Point2D(), Point2D()]
p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y, p[3].x, p[3].y = map(int, input().split())
"""
a = math.sqrt((p[1].x - p[0].x) ** 2 + (p[1].y - p[0].y) ** 2)
b = math.sqrt((p[2].x - p[1].x) ** 2 + (p[2].y - p[1].y) ** 2)
c = math.sqrt((p[3].x - p[2].x) ** 2 + (p[3].y - p[2].y) ** 2)
length = a + b + c
"""
for i in range(len(p) - 1):   # 1을 빼지 않으면 리스트의 범위를 벗어난 접근을 하게 되므로 주의
    length += math.sqrt((p[i + 1].x - p[i].x) ** 2 + (p[i + 1].y - p[i].y) ** 2)
print(length)
```

### 33. 예외 처리 사용하기
```
# 예외 처리 사용하기
# 예외란 코드를 실행하는 중에 발생한 에러를 뜻함
def ten_div(x):
    return 10/x
ten_div(0)
# 0을 넣으면 실행하는 중에 에러가 발생 ZeroDivisionError 예외가 발생

# try except로 사용
try:
    x = int(input("나눌 숫자를 입력하세요: "))
    y = 10 / x    # 예외가 발생하면 코드 실행을 중단하고 바로 except로 가서 코드 실행
    print(y)
except:
    print("예외가 발생했습니다.")
# try의 코드가 에러 없이 잘 실행 되면 except의 코드는 실행되지 않고 그냥 넘어감

# 특정 예외만 처리하기
# try:
#     실행할 코드
# except 예외이름:
#     예외가 발생했을 때 처리하는 코드
y = [10, 20, 30]

try:
    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())
    print(y[index]/x)
except ZeroDivisionError:
    print("숫자를 0으로 나눌 수 없습니다.")
except IndexError:
    print("잘못된 인덱스입니다.")
except ValueError:
    print('너무 많거나 적게 입력함')

y = [10, 20, 30]

try:
    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())
    print(y[index]/x)
except ZeroDivisionError as e:    # as 뒤에 변수를 지정하면 에러를 받아옴
    print("숫자를 0으로 나눌 수 없습니다.", e)    # e에 저장된 에러 메세지 출력
except IndexError as e:   # as 뒤에 변수를 지정하면 에러를 받아옴
    print("잘못된 인덱스입니다.", e)    # e에 저장된 에러 메세지 출력
except ValueError as e:   # as 뒤에 변수를 지정하면 에러를 받아옴
    print('너무 많거나 적게 입력함', e)   # e에 저장된 에러 메세지 출력

# 모든 예외의 에러 메세지를 출력할 때는 Exception을 사용
try:
    -1
except Exception as e:
    print("예외가 발생했습니다.", e)

# else와 finally 사용하기
try:
    실행할 코드
except:
    예외가 발생했을 때 처리하는 코드
else:
    예외가 발생하지 않았을 때 실행하는 코드

try:
  x = int(input())
  y = 10/x
except ZeroDivisionError:   # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨
    print('숫자를 0으로 나눌 수 없습니다.')
else:                       # try의 코드에서 예외가 발생하지 않았을 때 실행됨(except 생략 불가능)
    print(y)
finally:                    # 예외 발생 여부와 상관없이 항상 실행됨(except와 else 생략 가능)
    print('코드 실행이 끝났습니다.')

# 예외 발생 시키기
# raise 예외('에러메시지')
try:
    x = int(input())
    if x % 3 != 0:                                # x가 3의 배수가 아니면
        raise Exception('3의 배수가 아닙니다.')   # 예외를 발생시킴
    print(x)
except Exception as e:                            # 예외가 발생했을 때 실행됨
    print("예외가 발생했습니다.", e)

# 함수 안에서 raise를 사용하지만 함수 안에는 try except가 없는 상태
def three_multiple():
    x = int(input())
    if x % 3 != 0:                                  # x가 3의 배수가 아니면
        raise Exception('3의 배수가 아닙니다.')     # 예외를 발생시킴
    print(x)                                        # 현재 함수 안에는 except가 없으므로
                                                    # 예외를 상위 코드 블록으로 넘김
try:
    three_multiple()
except Exception as e:                              # 하위 코드 블록에서 예외가 발생해도 실행됨
    print('예외가 발생했습니다.', e)

# 함수 안에서 raise를 사용하지만 함수 안에는 try except가 없는 상태
def three_multiple():
    try:
        x = int(input())
        if x % 3 != 0:                                  # x가 3의 배수가 아니면
            raise Exception('3의 배수가 아닙니다.')     # 예외를 발생시킴
        print(x)
    except Exception as e:                    # 함수 안에서 예외를 처리함
        print('three_multiple 함수에서 예외가 발생했습니다.', e)
        raise     # raise로 현재 예외를 다시 발생시켜서 상위 코드 블록으로 넘김
                                                 
try:
    three_multiple()
except Exception as e:                              # 하위 코드 블록에서 예외가 발생해도 실행됨
    print('예외가 발생했습니다.', e)
# 이거 마지막에 3의 배수가 아닙니다. 는 왜 뜨는거지

# 예외 만들기(사용자 정의 예외)
class 예외이름(Exception):
    def __init__(self):
        super().__init__('에러메시지')

class NotThreeMultipleError(Exception):         # Exception을 상속받아서 새로운 예외를 만듦
    def __init__(self):
        super().__init__('3의 배수가 아닙니다.')

def three_multiple():
    try:
        x = int(input())
        if x % 3 != 0:                          # x가 3의 배수가 아니면
            raise NotThreeMultipleError         # NotThreeMultipleError 예외를 발생시킴
        print(x)
    except Exception as e:
        print('예외가 발생했습니다.', e)

three_multiple()

class NotThreeMultipleError(Exception):         # Exception만 상속받고
    pass                                        # 아무것도 구현하지 않음

def three_multiple():
    try:
        x = int(input())
        if x % 3 != 0:                          # x가 3의 배수가 아니면
            raise NotThreeMultipleError('3의 배수가 아닙니다.')   # 예외를 발생시킬 때 에러 메시지를 넣음
        print(x)
    except Exception as e:
        print('예외가 발생했습니다.', e)
three_multiple()

# 파일 예외 처리하기
try:
    file = open('maria.txt', 'r')
except FileNotFoundError:                 
    print('파일이 없습니다.')
else:
    s = file.read()
    file.close()

# 회문이 아니면 예외 발생 시키기
"""
class NotPalindromeError(Exception):
    pass

def palindrome(word):
    if list(word) != list(reversed(word)):
        raise NotPalindromeError('회문이 아닙니다.')
    print(word)
"""
class NotPalindromeError(Exception):
    def __init__(self):
        super().__init__('회문이 아닙니다.')
def palindrome(word):
    if word != word[::-1]:
        raise NotPalindromeError
    print(word)

try:
    word = input()
    palindrome(word)
except NotPalindromeError as e:
    print(e)
```

### 34. 이터레이터 사용하기
```
# 이터레이터 사용하기
# 이터레이터는 값을 차례대로 꺼낼 수 있는 객체임(반복가능한 객체)
dir([1, 2, 3])
it = [1, 2, 3].__iter__()
it.__next__()
it.__next__()
it.__next__()
it.__next__()
# 이터레이터는 next로 요소를 계속 꺼내다가 꺼낼 요소가 없으면 StopIteration 예외를 발생시켜서 반복을 끝냄

# 리스트뿐만 아니라 문자열, 딕셔너리, 세트도 __iter__를 호출하면 이터레이터가 나옴
# 이터레이터에서 __next__를 호출하면 차례대로 값을 꺼냄
it = range(3).__iter__()
it.__next__() # 0
it.__next__() # 1
it.__next__() # 2

# 반복가능한 객체 = 리스트, 튜플, range, 문자열, 딕셔너리, 세트
# 시퀀스 객체 = 리스트, 튜플, range, 문자열 (요소의 순서가 정해져있고 연속적으로 이어져있음)
# 딕셔너리와 세트는 연속적으로 이어져있지 않음

# 이터레이터 만들기
class 이터레이터이름:
    def __iter__(self):
        코드
    def __next__(self):
        코드

class Counter:
    def __init__(self, stop):
        self.current = 0    # 현재 숫자 유지, 0부터 지정된 숫자 직전까지 반복
        self.stop = stop    # 반복을 끝낼 숫자

    def __iter__(self):
        return self         # 현재 인스턴스 반환

    def __next__(self):
        if self.current < self.stop:    # 현재 숫자가 반복을 끝낼 숫자보다 작을 때
            r = self.current            # 반환할 숫자를 변수에 저장
            self.current += 1           # 현재 숫자를 1 증가시킴
            return r                    # 숫자를 반환
        else:                           # 현재 숫자가 반복을 끝낼 숫자보다 크거나 같을때
            raise StopIteration         # 예외 발생

for i in Counter(3):
    print(i, end=' ')
# 이터레이터를 만들 때는 __init__메서드에서 초깃값, __next__메서드에서 조건식과 현재값 부분을 주의해야 함

# 이터레이터 언패킹
a, b, c = Counter(3)
print(a, b, c)

# 자주 사용하는 map도 이터레이터임

# 인덱스로 접근할 수 있는 이터레이터 만들기
class 이터레이터이름:
    def __getitem__(self, 인덱스):
        코드

class Counter:
    def __init__(self, stop):
        self.stop = stop
    
    def __getitem__(self, index):
        if index < self.stop:
            return index
        else:
            raise IndexError

print(Counter(3)[0], Counter(3)[1], Counter(3)[2])

for i in Counter(4):
    print(i, end=' ')
# __getitem__이 있으면 __next__가 없어도 이터레이터가 됨
# 만약 초기값이 없다 하면은 __init__도 생략 가능함

# iter, next함수 활용하기
# iter는 객체의 __iter__메서드를 호출해주고 next는 객체의 __next__메서드를 호출해줌
it = iter(range(3))
next(it)
next(it)
next(it)

# iter는 반복을 끝낼 값을 지정하면 특정 값이 나올 때 반복을 끝냄
# iter(호출가능한객체, 반복을끝낼값)
import random
it = iter(lambda : random.randint(0, 5),2)    # 호출 가능한 객체를 넣어햐 하므로 매개변수가 없는 함수 또는 람다 표현식으로 만들어 줌
next(it)

import random
for i in iter(lambda : random.randint(0, 5), 2):
    print(i, end=' ')
# iter함수를 사용하면 if조건문으로 매번 숫자가 2인지 검사하지 않아도 되므로 코드가 좀 더 간단해짐

it = iter(range(3))
next(it, 10)
next(it, 10)
next(it, 10)
next(it, 10)
next(it, 10)

# 배수 이터레이터 만들기
class MultipleIterator:
    def __init__(self, stop, multiple):
        self.stop = stop
        self.multiple = multiple
        self.current = 0
                                 
 
    def __iter__(self):
        return self
 
    def __next__(self):
        self.current += 1
        if self.current * self.multiple < self.stop:
            return self.current * self.multiple
        else:
            raise StopIteration
                                                     
 
for i in MultipleIterator(20, 3):
    print(i, end=' ')
 
print()
for i in MultipleIterator(30, 5):
    print(i, end=' ')

# 시간 이터레이터 만들기
class TimeIterator:
    def __init__(self, start, stop):
        self.start = start
        self.stop = stop
    
    def __getitem__(self, index):
        if self.stop - self.start > index:
            time = (self.start + index)//60//60%24
            minute = (self.start + index)//60%60
            second = (self.start + index)%60
            return "{0:02d}:{1:02d}:{2:02d}".format(time, minute, second)
        else:
            raise IndexError


start, stop, index = map(int, input().split())
 
for i in TimeIterator(start, stop):
    print(i)
 
print('\n', TimeIterator(start, stop)[index], sep='')
```

### 35. 제너레이터 사용하기
```
# 제너레이터 사용하기
# 제너레이터는 이터레이터를 생성해주는 함수임
# 함수 안에서 yield라는 키워드만 사용하면 끝임
def number_generator():
    yield 0   # 0을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보
    yield 1
    yield 2

for i in number_generator():
    print(i)

g = number_generator()
g
dir(g)    # dir함수로 메서드 목록을 확인해보자

g.__next__()
# 이터레이터 동작과 동일함
# yield에 지정한 값이 __next__메서드의 반환값으로 나옴

def number_generator():
    yield 0   # 0을 함수 바깥으로 전달하면서 코드 실행을 함수 바깥에 양보
    yield 1
    yield 2

g = number_generator()

a = next(g)
print(a)
b = next(g)
print(b)
c = next(g)
print(c)

# 제너레이터 만들기
# range처럼 동장하는 제너레이터 만들기
def number_generator(stop):
    n = 0
    while n < stop:
        yield n
        n += 1

for i in number_generator(3):
    print(i)

def upper_generator(x):
    for i in x:
        yield i.upper()   # 함수의 반환값을 바깥으로 전달
                          # upper는 문자열을 대문자로 변환함
fruits = ['apple', 'pear', 'grape', 'pineapple', 'orange']
for i in upper_generator(fruits):
    print(i)

# yield from으로 값을 여러번 바깥으로 전달하기
def number_generator():
    x = [1, 2, 3]
    for i in x:
        yield i

for i in number_generator():
    print(i)

def number_generator():
    x = [1, 2, 3]
    yield from x    # 리스트에 들어있는 요소를 한 개씩 바깥으로 전달

for i in number_generator():
    print(i)

# yield from의 제너레이터 객체 지정하기
def number_generator(stop):
    n = 0
    while n < stop:
        yield n
        n += 1
  
def three_generator():
    yield from number_generator(3)    # 숫자를 세 번 바깥으로 전달

for i in three_generator():
    print(i)

# 파일 읽기 제너레이터 만들기
def file_read():
    with open('words.txt') as file:
        while True:     # 저장된 줄 수에 상관없이 읽기위해 무한루프
            line = file.readline()    # 한줄씩 읽기 위해 readline 사용
            if line == '':            # 한 줄을 읽은 뒤 내용이 빈 문자열이면
                break                 # break로 반복을 끝냄
            yield line.strip('\n')    # 내용이 들어있으면 \n을 삭제하고 yield로 문자열을 함수 바깥에 전달

for i in file_read():
    print(i)

# 소수 제너레이터 만들기
def prime_number_generator(start, stop):
    for n in range(start, stop):
        is_prime = True     # 소수 판별할 변수 만듦
        for i in range(2, n):
            if n % i == 0:
                is_prime = False
        if is_prime == True:
            yield n   

start, stop = map(int, input().split())
 
g = prime_number_generator(start, stop)
print(type(g))
for i in g:
    print(i, end=' ')
```

### 36. 코루틴 사용하기
```
# 코루틴 사용하기
# 메인루틴, 서브루틴
# 서브루틴이 끝나면 서브루틴의 내용은 모두 사라짐
# 코루틴은 종속관계가 아니라 대등한 관계임

# 코루틴에 값 보내기
# 코루틴은 yield로 값을 받아올 수 있음
# send로 코루틴에 값을 보냄
코루틴객체.send(값)
변수 = (yield)

def number_coroutine():
    while True:         # 코루틴을 계속 유지하기 위해 무한루프 사용
        x = (yield)     # 코루틴 바깥에서 값을 받아옴, yield를 괄호로 묶어야 함
        print(x)
  
co = number_coroutine()
next(co)    # 코루틴 안의 yield까지 코드 실행(최초실행)

co.send(1)  # 코루틴에 숫자 1을 보냄
co.send(2)  # 코루틴에 숫자 2을 보냄
co.send(3)  # 코루틴에 숫자 3을 보냄

# 코루틴 바깥으로 값 전달하기
변수 = (yield 변수)
변수 = next(코루틴객체)
변수 = 코루틴객체.send(값)

def sum_coroutine():
    total = 0
    while True:
        x = (yield total)     # 코루틴 바깥에서 값을 받아오면서 바깥으로 값을 전달
        total += x

co = sum_coroutine()
print(next(co))     # 0: 코루틴 안의 yield까지 코드를 실행하고 코루틴에서 나온 값 출력

print(co.send(1))   # 1: 코루틴에 숫자 1을 보내고 코루틴에서 나온 값 출력
print(co.send(2))   # 3: 코루틴에 숫자 2을 보내고 코루틴에서 나온 값 출력
print(co.send(3))   # 6: 코루틴에 숫자 3을 보내고 코루틴에서 나온 값 출력

# next는 코루틴의 코드를 실행하지만 값을 보내지는 않는다
# send는 값을 보내고 코루틴의 코드도 실행한다

# 코루틴을 종료하고 예외 처리하기
# 코루틴은 실행상태를 유지하기 위해 while True:를 사용해서 끝나지 않는 무한 루프로 작동함
# 코루틴을 강제로 종료하고 싶다면 close 메서드를 사용함
def number_coroutine():
    while True:
        x = (yield)
        print(x, end=' ')

co = number_coroutine()
next(co)

for i in range(20):
    co.send(i)

co.close()

# GeneratorExit 예외 처리하기
# 코루틴 객체에서 close 메서드를 호출하면 코루틴이 종료될 때 GeneratorExit예외가 발생함
def number_coroutine():
    try:
        while True:
            x = (yield)
            print(x, end=' ')
    except GeneratorExit:       # 코루틴이 종료될 때 GeneratorExit예외가 발생
        print()
        print('코루틴 종료')

co = number_coroutine()
next(co)

for i in range(20):
    co.send(i)

co.close()

# 코루틴 안에서 예외 발생시키기
# throw 메서드 사용
# throw 메서드에 지정한 에러 메시지는 except as 의 변수에 들어감
# 코루틴객체.throw(예외이름, 에러메시지)
def sum_coroutine():
    try:
        total = 0
        while True:
            x = (yield)
            total += x
    except RuntimeError as e:
        print(e)
        yield total     # 코루틴 바깥으로 값 전달

co = sum_coroutine()
next(co)

for i in range(20):
    co.send(i)

print(co.throw(RuntimeError, '예외로 코루틴 끝내기'))

# 하위 코루틴의 반환값 가져오기
# 변수 = yield from 코루틴()
def accumulate():
    total = 0
    while True:
        x = (yield)     # 코루틴 바깥에서 값을 받아옴
        if x is None:   # 받아온 값이 None이면
            return total# 합계 total을 반환
        total += x

def sum_coroutine():
    while True:
        total = yield from accumulate()   # accumulate의 반환값을 가져옴
        print(total)

co = sum_coroutine()      # ???
next(co)

for i in range(1, 11):    # 1부터 10까지 반복
    co.send(i)            # 코루틴 accumulate에 숫자를 보냄
co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄

for i in range(1, 101):   # 1부터 100까지 반복
      co.send(i)          # 코루틴 accumulate에 숫자를 보냄
co.send(None)             # 코루틴 accumulate에 None을 보내서 숫자 누적을 끝냄

# 문자열 검색 코루틴 만들기
def find(word):
    a = True
    while True:
        x = (yield a)
        a = word in x


f = find('Python')
next(f)
 
print(f.send('Hello, Python!'))
print(f.send('Hello, world!'))
print(f.send('Python Script'))
 
f.close()

# 사칙연산 코루틴 만들기

def calc():
    result = 0
    while True:
        line = (yield result)      # 코루틴 바깥에서 계산식 받아옴(아직 문자열임)
        if '+' in line:     # 문자열 계산식에 +가 있으면
            a, b = line.split(' + ')
            result = int(a) + int(b)
        elif '-' in line:     # 문자열 계산식에 -가 있으면
            a, b = line.split(' - ')
            result = int(a) - int(b)
        elif '*' in line:     # 문자열 계산식에 *가 있으면
            a, b = line.split(' * ')
            result = int(a) * int(b)
        elif '/' in line:     # 문자열 계산식에 /가 있으면
            a, b = line.split(' / ')
            result = int(a) / int(b)


expressions = input().split(', ')     # 문자열로 입력받고 리스트로 저장
 
c = calc()
next(c)     # 코루틴에서 yield까지 읽기
 
for e in expressions:     # 반복문으로 문자열 형태의 계산식 각각 나눔
    print(c.send(e))      # 나눈걸 코루틴에 보내벌임
 
c.close()
```

### 37. 데코레이터 사용하기
```
# 데코레이터 사용하기
# 클래스에서 메서드를 만들 때 @로 시작하는 것들이 데코레이터임
class Calc:
    @staticmethod   # 데코레이터
    def add(a, b):
        print(a + b)

# 데코레이터는 함수를 수정하지 않은 상태에서 추가 기능을 구현할 때 사용함
def hello():
    print('H함수시작')
    print('hello')
    print('H함수 끝')
hello()

def trace(func):                          # 호출할 함수를 매개변수로 받음
    def wrapper():                        # 호출할 함수를 감싸는 함수
        print(func.__name__, '함수 시작') # __name__으로 함수 이름 출력
        func()                            # 매개변수로 받은 함수를 호출
        print(func.__name__, '함수 끝')
    return wrapper                        # wrapper 함수 반환

@trace      # 데코레이터
def hello():
    print('hello')

@trace      # 데코레이터
def world():
    print("world")

trace_hello = trace(hello)      # 데코레이터에 호출할 함수를 넣음
trace_hello()                   # 반환된 함수를 호출
trace_world = trace(world)      # 데코레이터에 호출할 함수를 넣음
trace_world()                   # 반환된 함수를 호출

@데코레이터
def 함수이름():
    코드

# 매개변수와 반환값을 처리하는 데코레이터 만들기
def trace(func):          # 호출할 함수를 매개변수로 받음
    def wrapper(a, b):    # 호출할 함수 add(a, b)의 매개변수와 똑같이 지정 
        r = func(a, b)    # func에 매개변수 a, b를 넣어서 호출하고 반환값을 변수에 저장
        print('{0}(a={1}, b={2}) -> {3}'.format(func.__name__, a, b, r))    # 매개변수와 반환값 출력
        return r          # func의 반환값을 반환
    return wrapper        # wrapper 함수 반환

@trace             # @데코레이터
def add(a, b):     # 매개변수는 두개
    return a + b   # 매개변수 두 개를 더해서 반환

print(add(10, 20))
# 먼저 안쪽에 있는 wrapper함수의 매개변수를 호출할 add(a, b)매개변수와 똑같이 만들어주셈


# 매개변수가 고정되지 않은 함수
def trace(func):                    # 호출할 함수를 매개변수로 받음
    def wrapper(*args, **kwargs):   # 가변인수를 함수로 만듦
        r = func(*args, **kwargs)   # func에 args, kwargs를 언패킹하여 넣어줌
        print('{0}(args={1}, kwargs={2}) -> {3}'.format(func.__name__, args, kwargs, r))
                                    # 매개변수와 반환값 출력
        return r                    # func의 반환값을 반환
    return wrapper                  # wrapper 함수 반환

@trace                  # @데코레이터
def get_max(*args):     # 위치 인수를 사용하는 가변 인수 함수
    return max(args)

@trace                  # @데코레이터
def get_min(**kwargs):  # 키워드 인수를 사용하는 가변 인수 함수
    return min(kwargs.values())

print(get_max(10, 20))
print(get_min(x = 10, y = 20, z = 30))

@trace
def add(a, b):
    return a + b

add(10, 20)
add(50, 20)

# 매개변수가 있는 데코레이터 만들기
# 매개변수가 있는 데코레이터를 만들 때는 함수를 하나 더 만들어야함
def is_multiple(x):             # 데코레이터가 사용할 매개변수를 지정
    def real_decorator(func):   # 호출할 함수를 매개변수로 받음
        def wrapper(a, b):      # 호출할 함수의 매개변수와 똑같이 지정
            r = func(a, b)      # func를 호출하고 반환값을 변수에 저장
            if r % x == 0:      # func의 반환값이 x의 배수인지 확인
                print("{0}의 반환값은 {1}의 배수입니다.".format(func.__name__, x))
            else:
                print("{0}의 반환값은 {1}의 배수가 아닙니다.".format(func.__name__, x))
            return r            # func의 반환값을 반환
        return wrapper          # wrapper함수 반환
    return real_decorator       # real_decorator 함수 반환
@is_multiple(3)     # @데코레이터(인수)
def add(a, b):
    return a + b

print(add(10, 20))
print(add(2, 5))

# 클래스로 데코레이터 만들기
class Trace:
    def __init__(self, func):     # 호출할 함수를 인스턴스의 초깃값으로 받음
        self.func = func          # 호출할 함수를 속성 func에 저장
        
    def __call__(self):
        print(self.func.__name__, '함수 시작')    # __name__으로 함수 이름 출력
        self.func()                               # 속성 func에 저장된 함수를 호출
        print(self.func.__name__, '함수 끝')
        ,
@Trace    # @데코레이터
def hello():
    print("hello")

hello()     # 함수를 그대로 호출

# 클래스로 매개변수와 반환값을 처리하는 데코레이터 만들기
class Trace:
    def __init__(self, func):     # 호출할 함수를 인스턴스의 초깃값으로 받음
        self.func = func          # 호출할 함수를 속성 func에 저장
    
    def __call__(self, *args, **kwargs):      # 호출할 함수의 매개변수를 처리
        r = self.func(*args, **kwargs)      # self.func에 매개변수를 넣어서 호출하고 반환값을 변수에 저장
        print("{0}(args={1}, kwargs={2}) -> {3}".format(self.func.__name__, args, kwargs, r))
                                              # 매개변수의 반환값 출력
        return r                              # self.func의 반환값을 반환

@Trace      # @데코레이터
def add(a, b):
    return a + b

print(add(10, 20))
print(add(a = 10, b = 20))

# 함수의 반환값이 특정 수의 배수인지 확인하는 데코레이터
class IsMultiple:
    def __init__(self, x):      # 데코레이터가 사용할 매개변수를 초깃값으로 받음
        self.x = x              # 매개변수를 속성 x에 저장

    # __call__메서드는 클래스로 데코레이터를 만들 때 구현해야 함
    def __call__(self, func):   # 호출할 함수를 매개변수로 받음
        def wrapper(a, b):      # 호출할 함수의 매개변수와 똑같이 지정(가변 인수로 작성해도 됨)
            r = func(a, b)      # func를 호출하고 반환값을 변수에 저장
            if r % self.x == 0: # func의 반환값이 self.x의 배수인지 확인
                print('{0}의 반환값은 {1}의 배수입니다.'.format(func.__name__, self.x))
            else:
                print('{0}의 반환값은 {1}의 배수가 아닙니다.'.format(func.__name__, self.x))
            return r            # func의 반환값을 반환
        return wrapper          # wrapper 함수 반환

@IsMultiple(3)    # 데코레이터(인수)
def add(a, b):
    return a + b

print(add(10, 20))
print(add(2, 5))

# 데코레이터로 매개변수의 자료형 검사하기
def type_check(x, y):
    def real_decorator(func):
        def wrapper(a, b):
            if isinstance(a, x) and isinstance(b, y):
                return func(a, b)
            else:
                raise RuntimeError('자료형이 올바르지 않습니다.')
        return wrapper
    return real_decorator

@type_check(int, int)
def add(a, b):
    return a + b
 
print(add(10, 20))
print(add('hello', 'world'))

# HTML 태그 데코레이터 만들기
def html_tag(x):
    def real_decorator(func):
        def wrapper():
            r = func()
            return '<{0}>{1}</{0}>'.format(x,r)
        return wrapper
    return real_decorator

a, b = input().split()
 
@html_tag(a)
@html_tag(b)
def hello():
    return 'Hello, world!'
 
print(hello())
```

### 38. 정규표현식 사용하기
```
# 정규표현식 사용하기
# 정규표현식은 일정한 규칙(패턴)을 가진 문자열을 표현하는 방법
import re     # re모듈을 가져와서 match함수에 정규표현식 패턴과 판단할 문자열을 넣음
re.match('hello', 'hello, world!')

# 문자열이 맨 앞에 오는지 맨 뒤에 오는지 판단하기
# 문자열 앞에 ^를 붙이면 문자열이 맨 앞에 오는지 판단하고, 문자열 뒤에 $를 붙이면 문자열이 맨 뒤에 오는지 판단함(특정 문자열로 끝나는지)
# ^문자열, 문자열$
# 이때는 match대신 search함수를 사용해야함
re.search("^hello","hello, world!")     # hello로 시작하므로 패턴에 매칭됨

re.search("world!$","hello, world!")      # world!로 끝나므로 패턴에 매칭됨

# 지정된 문자열이 하나라도 포함되는지 판단하기
# 개념은 or연산자와 같음
# 'hello|world'는 문자열에서 hello 또는 world가 포함되는지 판단함
re.match("hello|world", "hello")      # hello또는 world가 있으므로 패턴에 매칭됨

# 범위 판단하기
# 대괄호 안에 숫자 범위를 넣으며 * 또는 +를 붙임
# 범위는 0-9처럼 표현하며 *는 문자(숫자)가 0개 이상있는지, +는 1개 이상 있는지 판단함
re.match('[0-9]*', '1234')
re.match('[0-9]+', '1234')
re.match('[0-9]+', 'abcd')
re.match('a*b', 'b')      # b에는 a가 0개 이상 있으므로 패턴에 매칭됨
re.match("a+b", 'b')
re.match('a*b','abbb')
re.match("a+b",'aab')

# 문자가 한 개만 있는지 판단하기
# ?와 .을 사용함
# ?는 문자 0개 또는 1개인지 판단하고, .은 문자 1개인지 판단함
re.match('H?','H')
re.match('H?','HI')
re.match('H.','HHH')

# 문자 개수 판단하기
re.match("h{3}", 'hhhhello')
re.match("(hello){3}","hellohellohelloworld")
re.match('h{3}','hellohhhh')

# 특정 범위의 문자(숫자)가 몇 개 있는지 판단할 수도 있음
# [0-9]{개수}
re.match('[0-9]{3}-[0-9]{4}-[0-9]{4}', '010-1000-1000')

# 숫자와 영문 문자를 조합해서 판단하기
re.match('[a-zA-Z0-9]+', 'Hello1234')     #a부터 z, A부터 Z, 0부터 9까지 1개이상 있으므로 패턴에 매칭됨

# 문정 문자 범위에 포함되지 않는지 판단하기
# [^범위]*
# [^범위]+
# 문자, 숫자 범위 앞에 ^를 붙이면 해당 범위를 제외함
re.match('[^A-Z]+', 'hello')      # 대문자를 제외, 대문자가 있으므로 패턴에 매칭되지 않음

# 범위를 제외할 때는 [^A-Z]+와 같이 []안에 넣어주고
# 특정 문자 범위로 시작할 때는 ^[A-Z]+와 같이 []앞에 붙여줌
# 특정 문자(숫자) 범위로 끝나는지 확인할 때는 정규표현식 뒤에 $를 붙이면 됨
# [범위]*$
# [범위]+$
# 특수문자 판단하기
# 특수문자 앞에 \를 붙이면 됨
re.search('\*+', '1 ** 2')      # *이 들어있는지 판단
re.match("[$()a-zA-z0-9]+", "$(document)")      # $, (, )와 문자, 숫자가 들어있는지 판단

# 단순히 숫자인지 문자인지 판단할 떄는 \d \D \w \W를 사용하면 편함
# \d [0-9]와 같음, 모든숫자
# \D [^0-9]와 같음, 숫자를 제외한 모든 문자
# \w [a-zA-z0-9_]와 같음, 영문 대소문자, 숫자, 밑줄 문자
# \W [^a-zA-z0-9_]와 같음, 영문 대소문자, 숫자, 밑줄 문자를 제외한 모든 문자
re.match('\d+', '1234')

# 공백은 ''처럼 공백 문자를 넣어도 되고, \s또는 \S로 표현할 수도 있음

# 그룹 사용하기
# 정규표현식 그룹은 해당 그룹과 일치하는 문자열을 얻어올 때 사용함
m = re.match('([0-9]+) ([0-9]+)', '10 295')
m.group(1)      # 첫 번째 그룹(그룹 1)에 매칭된 문자열을 반환
m.group(2)
m.group()       # 매칭된 문자열을 한꺼번에 반환
m.group(0)      # 매칭된 문자열을 한꺼번에 반환

m.groups()      # 각 그룹에 해당하는 문자열을 튜플 형태로 반환

# 그룹 이름 짓기
# (?P<이름>정규표현식)
m = re.match('(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)', 'print(1234)')
m.group('func')

# 그룹 지정 없이 패턴에 매칭되는 모든 문자열을 가져오려면 findall함수를 사용하여 매칭된 문자열을 리스트로 반환함
re.findall('[0-9]+', '1 2 Fizz 4 Buzz Fizz 7 8')

# 문자열 바꾸기
# 문자열을 바꿀 때는 sub함수를 사용하여 패턴, 바꿀 문자열, 문자열, 바꿀 횟수를 넣어줌
re.sub('apple|orange', 'fruit', 'apple box orange tree')    # apple 또는 orange를 fruit로 바꿈

re.sub('[0-9]+', 'n', '1 2 Fizz 4 Buzz Fizz 7 8')

# sub함수는 바꿀 문자열 대신 교체 함수를 지정할 수도 있음
# 교체함수(매치객체)
# re.sub('패턴', 교체함수, '문자열', 바꿀횟수)
def multiple10(m):
    n = int(m.group())
    return str(n * 10)

re.sub('[0-9]+', multiple10, '1 2 Fizz 4 Buzz Fizz 7 8')

# 교체 함수의 내용이 간단하다면 다음과 같이 람다 표현식을 만들어서 넣어도 됨
re.sub('[0-9]+', lambda m: str(int(m.group())*10), '1 2 Fizz 4 Buzz Fizz 7 8')

# 찾은 문자열을 결과에 다시 사용하기
# \\숫자
re.sub('([a-z]+) ([0-9]+)', '\\2 \\1 \\2 \\1', 'hello 1234')    # 그룹 2, 1, 2, 1 순으로 바꿈

re.sub('({\s*)"(\w+)":\s*"(\w+)"(\s*})', '<\\2>\\3</\\2>', '{ "name": "james" }')

# 만약 그룹에 이름을 지었다면 \\g<이름> 형식으로 매칭된 문자열을 가져올 수 있음(\\g<숫자> 형식으로 숫자를 지정해도 됨)
# \\g<이름>
# \\g<숫자>
re.sub('({\s*)"(?P<key>\w+)":\s*"(?P<value>\w+)"(\s*})', '<\\g<key>>\\g<value></\\g<key>>', '{ "name": "james" }')

# 이메일 주소 검사하기
import re

p = re.compile('^[a-zA-z0-9+-_.]+@[a-zA-Z0-9-]+\.[a-zA-z0-9-.]+$')
emails = ['python@mail.example.com', 'python+kr@example.com',              # 올바른 형식
          'python-dojang@example.co.kr', 'python_10@example.info',         # 올바른 형식
          'python.dojang@e-xample.com',                                    # 올바른 형식
          '@example.com', 'python@example', 'python@example-com']          # 잘못된 형식
 
for email in emails:
    print(p.match(email) != None, end=' ')

# URL 검사하기
import re
URL = input()
print(re.match('^https?://[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+/[a-zA-Z0-9-_/.?=]*', URL) != None)
```

### 39. 모듈과 패키지 사용하기
```
# 모듈과 패키지 사용하기
# import 모듈
# import 모듈1, 모듈2
# 모듈.변수
# 모듈.함수()
# 모듈.클래스()
import math
math.pi           # 파이
math.sqrt(4.0)    # 제곱근 함수
math.sqrt(2.0)

# import as로 모듈 이름 지정하기
import math as m  # math모듈을 가져오면서 이름을 m으로 지정
m.sqrt(2.0)

# from import로 모듈의 일부만 가져오기
# from 모듈 import 함수, 클래스, 변수
from math import pi     # math모듈에서 변수 pi만 가져옴
pi
from math import sqrt   # math모듈에서 sqrt 함수만 가져옴
sqrt(4.0)
from math import pi, sqrt     # 여러개 가져오는 것도 가능함

# 모듈의 모든 변수, 함수, 클래스를 가져오는 기능
from math import *    # math모듈에 있는 모든 변수, 함수, 클래스를 가져옴
from math import sqrt as s      # math 모듈에서 sqrt 함수를 가져오면서 이름을 s로 지정
from math import pi as p, sqrt as s     # math 모듈에서 여러개의 함수를 가져오면서 각각 이름을 지정

# import로 패키지 가져오기
# 패키지는 특정 기능과 관련된 여러 모듈을 묶은 것인데, 패키지에 들어있는 모듈도 import를 사용하여 가져옴
# import 패키지.모듈
# import 패키지.모듈1, 패키지.모듈2
# 패키지.모듈.변수
# 패키지.모듈.함수()
# 패키지.모듈.클래스()
import urllib.request   # urllib 패키지의 request 모듈을 가져옴
response = urllib.request.urlopen('http://www.google.co.kr')    # 패키지.모듈.함수()
response.status   
# 200은 http상태코드가 잘 입력되었다는 것을 알려준 것

# 파이썬 패키지 인덱스에서 패키지 설치하기
# pip설치하기(pip는 파이썬 패키지 인덱스의 패키지 관리 명령어임)
# pip install 패키지(윈도우에서는 명령프롬프트를 실행하고 pip install request 명령을 입력함)

# python에 -m옵션을 지정해서 pip를 실행할 수도 있음
# -m pip install requests

# pip로 설치한 패키지 가져오기
# import 패키지 or import 패키지.모듈

# 소수점 이하 올림, 버림 구하기
from math import ceil, floor

x = 1.5

print(ceil(x), floor(x))

# 원의 넓이 구하기
from math import pi
a = float(input())
print(a*a*pi)
```

### 40. 모듈과 패키지 만들기
```
# 모듈과 패키지 만들기
from google.colab import drive

from google.colab import drive
drive.mount('/content/drive')

!pwd	# 현재 위치 확인

# square2.py 라는 모듈 폴더를 만듦
"""
base = 2

def square(n):
    return base ** n
"""
import square2

print(square2.base)
print(square2.square(10))

from square2 import base, square
print(base)
square(10)

# person.py
"""
class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

    def greeting(self):
        print('안녕하세요. 저는 {0}입니다'.format(self.name))
"""
import person

maria = person.Person('마리아', 20, '서울시 서초구 반포동')
maria.greeting()

from person import Person   # 모듈 이름을 붙이지 않고 사용할 수도 있음

maria = Person('마리아', 20, '서울시 서초구 반포동')
maria.greeting()

# 모듈과 시작점 알아보기
"""
if __name__ == '__main__':
    코드
이 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업임

# hello.py
print("hello모듈 시작")
print("hello.py __name__:", __name__)
print("hello모듈 끝")
"""
import hello
print("main.py __name__:", __name__)

import calc
calc.add(50, 60)
calc.mul(50, 60)

# 폴터(디렉터리) 안에 __init__.py파일이 있으면 해당 폴더는 패키지로 인식됨
"""
# operation.py
def add(a, b):
    return a + b

def mul(a, b)
    return a * b

# geometry.py
def triangle_area(base, height):
    return base * height / 2

def rectangle_area(width, height):
    return width = height
"""

# 패키지 사용하기
import calcpkg.operation
import calcpkg.geometry
a = int(input())
print(calcpkg.operation.squareroot(a))
print(calcpkg.geometry.circle_area(a))
```
